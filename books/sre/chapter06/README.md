# CHAPTER 06. Monitoring Distributed Systems

<i>분산 시스템 모니터링</i>

### 정의

#### 모니터링

\: 시스템의 정량적 실시간 데이터를 모으고 처리하고 집계해서 보여주는 것

(시스템 데이터: 쿼리의 수와 종류, 에러의 수와 종류, 처리시간 및 서버의 활동 시간 등)

#### 화이트박스(white-box) 모니터링

\: 로그나 자바 가상 머신 (Java Virtual Machine, JVM) 의 프로파일링 인터페이스 (profling interface) 같은 인터페이스 혹은 내부의 통계 지표를 제공하는 HTTP 핸들러 등을 이용해서 얻은 시스템의 내부 지표들을 토대로하는 모니터링

#### 블랙박스 (black-box) 모니터링

\: 사용자가 보게 되는 확인 가능한 동작들을 외부에서 테스트하는 과정

#### 대시보드 (dash board)

\: 서비스의 핵심 지표에 대한 요약된 뷰를 보여주는 (주로 웹 기반) 애플리케이션

대시 보드는 필터나 선택 옵션등을 제공하기도 하지만, 가장 중요한 지표들을 사용자에게 보여주도록 만들어져 있음.
또한 쌓여있는 티켓의 숫자나 높은 우선순위를 갖는 버그의 목록, 현재 비상 대기중인 엔지니어와 담당하는 분야 혹은 최근에 배포된 코드 등 팀과 관련된 정보를 보여주기도 함

#### 알림 (alert)

\: 사람이 읽을 수 있도록 작성된 통지(noification) 를 말하며, 주로 버그나 티켓 큐, 메일, 혹은 호출기 등으로 보내짐.

이런 알림들은 각각 티켓, 메일 알림 및 호출 등으로 분류됨

#### 근본원인

\: 소프트웨어 시스템의 결함이나 사람의 실수는 일단 고쳐지면 그 일이 다시는 발생하지 않을 것이라는 확신을 심어줌

이런 사고는 여러 원인에 의해 발생할 수 있음

예를 들어 프로세스의 자동화가 충분하지 못해서 발생할 수도 있고, 조작된 정보에 의해 소프트웨어가 충돌해서 발생할수도 있고, 설정을 생성하는 스크립트의 테스트가 제대로 수행되지 않아 발생할 수도 있음

모두 수정 되어야함

#### 노드와 머신

\: 물리적인 서버, 가상머신 혹은 컨테이너(container)에서 동작하는 커널의 단일 인스턴스를 의미하며 동의어로 사용됨

한 머신이 모니터링할 여러 개의 서비스를 운영하고 있을 수도 있는데, 크게 두 가지로 구분할 수 있음

- 서로 관련된 서비스: 캐시 서버와 웹서버
- 서로 관련이 없지만 하드웨어만 공유하는 서비스: 코드 저장소와 퍼펫 (Puppe)이나 셰프(Chef) 같은 설정 시스템의 마스터 노드

#### 푸시 (push)

\: 서비스가 실행하는 소프트웨어나 관련된 설정에 대한 모든 변경사항

<br/>

### 왜 모니터링 해야 하는가?

언제 문제가 발생했는지 또는 어떤 문제가 발생하려 하는지를 알 수 있음

효과적인 알림 시스템은 정확한 신호와 낮은 오보 비율을 갖춰야 함

- 장기적인 트렌드 분석
- 시간순 혹은 실험 그룹에 대한 비교
    - 어느 것이 쿼리를 더 빨리 실행 하는가?
    - 노드를 추가했을 때 멤캐시(memcache)의 활용률(hit rate)은 어느정도나 좋아지는가?
    - 지난주 대비 사이트가 느려졌는가?
- 알림
- 대시보드: 네 가지 골든 신호를 포함
- 임시적인 회고 분석의 수행 (예 를 들 면 디 버 깅 등)

<br/>

### 모니터링에 대한 적절한 기대치 설정

- 최대한 간결하면서도 팀 모두가 이해 할 수 있도록 유지하는 것
    - (특히 프로덕션 환경에서 문제가 발생해서 사람을 호출하고, 기본적인 점검과 심도 깊은 디버깅을 실행하기까지의 경로를)
- 잘못된 알림(noise) 비율을 낮게 유지하고 올바른 알림의 비율을 높게 유지하기 위해서는 호출을 담당하는 모니터링 시스템은 반드시 간결하면서도 안정적이어야 함
- 사람이 확인할 알림을 발송하기 위한 규칙들은 이해하기 쉽고 문제를 명확하게 표현할 수 있어야 함

<br/>

### 증상과 원인

| 증상                                      | 원인                                                               |
|-----------------------------------------|------------------------------------------------------------------|
| **"어떤 장애가 발생했는가?" - 무엇**                | **"왜 장애가 발생했는가?" - 왜**                                           |
| HTTP 500 이나 404 오류                      | 데이터베이스 서버가 연결 요청을 거부함                                            |
| 응답 속도가 느려짐                              | 비효율적인 로직에 의한 CPU 과부하가 발생함 또는 랙 아래의 이더넷 케이블 파손으로 인한 패킷이 부분적으로 유실됨 |
| 남극의 사용자가 고양이가 등장하는 애니메이션 GIF파일을 수신하지 못함 | CDN 서비스가 과학자와 고양잇과 동물을 싫어해서 일부 IP를 블랙리스트에 등록했음                   |
| 개인정보가 유출                                | 새로 배포한 소프트웨어가 ACL을 잘못 설정해서 모든 요청에 응답함                            |

'무엇'과 '왜'는 최대 비율의 정상적 알림과 최소 비율의 오보를 목적으로 하는 모니터링 시스템을 작성할 때 고려해야 하는 가장 중요한 간극 중 하나

<br/>

### 블랙박스와화이트박스

- **블랙박스 모니터링**: 서버 상에 나타나는 증상을 기본으로 하며 현재 문제가 (발생할 것으로 예상되는 것이 아니라) 발생하는 상황을 모니터링하는 것
    - 즉,시스템이 지금 현재 올바로 동작하지 않고 있는 상황을 알기 위한 것
- **화이트박스 모니터링**: 로그나 HTTP 종단점(endpoint)과 같은 시스템의 내부 동작들을 규범에 따라 살펴보는 기법들을 토대로 함
    - 문제가 발생하려는 재시도에 의해 가려진 실패 작업 등을 포착할 수 있음
    - 원격으로 디버깅을 수행할 때는 화이트박스 모니터링이 필수적

<br/>

### 네 가지 결정적인 지표

- 지연응답: 요청이서비스에의해처리되기까지의시간
    - 빠르게 리턴된 에러보다는 느리게 리턴된 에러가 더 중요
- 트래픽: 시스템에 얼마나 많은 요청이 들어오는지를 측정
    - 초당 HTTP 요청의 개수로 측정
- 에러: 실패한 요청의 비율
    - 명시적인 실패(ex. HTTP 500)과 묵시적인 실패(ex. HTTP 200이지만 잘못된 콘텐츠가 제공된 경우), 혹은 정책과 관련된 실패(ex. 모든 응답을 1초내에 제공하기로 했다면 1초 이상 소요된 응답은 에러)등을 모두 고령해야함
    - 로드밸랜서를 통해 모든 HTTP 500에러를 검출하면 실패한 요청들을 모두 완벽하게 잡아낼 수 있음
- 서비스 포화 상태
    - 서비스가 얼마나 '포화 상태'로 동작 하는지를 의미
    - 시스템의 일부를 측정하며 가장 병목이 발생하는 리소스를 집중해서 측정해야 함
    - CPU 사용량이 나 이미 상한선이 분명한 네 트워크 대역폭 같은 간접적인 신호들을 사 용할 수밖에 없음

<br/>

### 마지막요청(혹은실행과성능)에대한고려

평균응답시간이느려지는것과마지막요청(ail ofrequests)이아주느려지는것을 구분 하 는 간 단 한 방 법 은 실 제 지 연 응 답 이 아 니 라 전 체 요 청 의 수 와 전 체 지연 응 답 을 수집 하는것

분포의경계를대략적으로산정해서분포해보면(이예시의경우에는대충세가 지범위만을추출해서분포해보면) 요청이어떻게분포되는지를시각적으로확인할수있다.

<br/>

### 적당한측정방법선택하기

여러서버에걸쳐데이터를수집하고시계열로집계하는외부시스템을구성하면 비용을줄일수있다

1. 매 초마다 현재 CPU의 사용량을 기록
2. 5 % 단위로 버킷(bucket)을 구성하고 매 초당 CPU 사용량을 측정하여 적절한 버킷의 값을 증가시킨다.
3. 분 단위로 이 값들을 집계

<br/>

### 더욱단순하게가아니라최대한단순하게

- 가장 빈 번 하 게 발 생 하 는 사 건/ 사 고 를 탐 지 하 기 위 한 규 칙 은 최 대 한 간 결 하 고 예 측 가 능 하며 확 실해야 한다.
- 수정 빈도가 높지 않은(어떤SRE팀은 분기에 한번 수정하기도 하는) 데이터의 수집, 집계 그리고 알림에 관련된 설정은 제거하는 것이 좋음
- 수집은 되지만 대시보드에 노출되지도 않고 알림에 사용되지도 않는 데이터는 역시 제거하는 것이 좋음

### 지금까지살펴본원리들을결합하기

- 매번호출기가울릴때마다긴급한상황임을인지하고그에대응할수있어야한다. 이 러 한 긴 급 호 출 은 빈 번 한 호 출 로 인 한 피 로 를 느 끼 지 않 도 록 하 루에 단 몇 번 정 도 만 발 생해야한다.
- 모든호출은대응이가능해야한다.
- 호출에대한모든대응은이성적이어야한다. 만일호출이자동화된응답에대해서만 가 치 가 있 다 면 이 호 출 은 전 파 되 어 서 는 안 된 다.
- 호출은새로운문제나지금까지보지못한사건에대한것이어야한다.

- 위 시스템의 복잡도에 관계없이 올바른 질문을 던지는데 도움을 주는 질문들

- 이규칙은해당규칙이존재하지않는다면알아챌수없는긴급하고, 대처가가능하며 즉각적으로사용자가인지할수있는상태를탐지할수있는가?
- 긴 급 하 지 않 은 알 림 이 라 면 무 시 할 수 있 는 알 림 인 가 ? 언 제, 왜 이 알 림 을 무 시 할 수 있 으며, 이런알림을받지않으려면어떻게해야할까?
- 이알림은분명히사용자에게좋지않은영향을미치는상황에대한알림인가?
- 가용트 래픽이모두소모되었거나테스트배포처럼사용자에게부정적인영향을미치지않는 경우에는알림이발생하지는않았는가?
- 이알림에대해대응이가능한가?이알림은긴급한것인가아니면내일아침까지기다 려도되는것인가? 대응책은안전하게자동화가가능한가? 알림에대한대응은장기적 인수정이될것인가아니면단기적인우회책이될것인가?
- 다른사람들이이이슈에대한호출을받아서적어도하나이상의불필요한호출이 발생했는가?

### 장기적모니터링

누군가문제의근본적인원인을찾아해결해야한다. 만일해결이불가능하다면알림에대한대 응이완전히자동화되어야한다.

<br/><br/>
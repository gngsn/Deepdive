# CHAPTER 07. 객체 분해

**TL;DR**
- 추상화: 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
- 분해(decomposition): 큰 문제를 해결 가능한 작은 문제로 나누는 작업
- 소프트웨어는 **데이터**를 이용해 정보를 표현하고 **프로시저**를 이용해 데이터를 조작
  - 프로시저 추상화: = 기능 분해, 알고리즘 분해. 소프트웨어가 무엇을 해야 하는지를 추상화.
  - 데이터 추상화: 소프트웨어가 무엇을 알아야 하는지를 추상화
- 모듈은 퍼블릭 인터페이스를 외부에 제공해서 복잡성과 변경 가능성을 감춰야 한다.
- 클래스는 절차를 추상화(procedural abstraction), 추상 데이터 타입은 타입을 추상화(type abstraction).
- 추상 데이터 타입과 객체지향 설계의 유용성은 설계에 요구되는 변경의 압력이 '타입 추가'에 관한 것인지, 아니면 '오퍼레이션 추가'에 관한 것인지에 따라 달라짐
  - 변경의 압력이 **타입 추가하는 것**이라면 더 강한 경우에는 객체지향
  - 변경의 압력이 **오퍼레이션을 추가하는 것**이라면 추상 데이터 타입


<br/>

- 추상화: 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
- 분해(decomposition): 큰 문제를 해결 가능한 작은 문제로 나누는 작업

## 01. 프로시저 추상화와 데이터 추상화

- 소프트웨어는 **데이터**를 이용해 정보를 표현하고 **프로시저**를 이용해 데이터를 조작
- 객체 지향 = 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것 
  - 객체지향은 클래스라는 도구를 제공, 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용해 시스템을 분해하는 방법임


### 프로시저 추상화와 기능 분해
_소프트웨어가 무엇을 해야 하는지를 추상화_

프로시저 추상화를 중심으로 시스템을 분해
- = 기능 분해(functional decomposition), 알고리즘 분해(algorithmic decomposition)
- 보통 하향식 접근법(Top-Down Approach)

<br/>

#### 급여 관리 시스템

```txt
급여 = 기본급 – (기본급 * 소득세율)
```

**TOP**: 직원의 급여를 계산한다
```txt
직원의 급여를 계산한다
    사용자로부터 소득세율을 입력받는다
    직원의 급여를 계산한다
    양식에 맞게 결과를 출력한다
```

추가적으로 정제 가능한 문장이 존재하면, 구현이 가능할 정도로 충분히 저수준의 문장이 될 때까지 기능을 분해

```txt
직원의 급여를 계산한다
    사용자로부터 소득세율을 입력받는다
        "세율을 입력하세요: "라는 문장을 화면에 출력한다
        키보드를 통해 세율을 입력받는다
    직원의 급여를 계산한다
        전역 변수에 저장된 직원의 기본급 정보를 얻는다
        급여를 계산한다
    양식에 맞게 결과를 출력한다
        "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다
```

<br/>

### 급여 관리 시스템 구현


<table>
<tr>
<th>문장</th>
<th>함수 정의</th>
</tr><tr><td>

- 직원의 급여를 계산한다.

</td><td>

```ruby
def main(name)
end
```

</td></tr><tr><td>

- 직원의 급여를 계산한다.
  - <b>사용자로부터 소득세율을 입력받는다.</b>
  - <b>직원의 급여를 계산한다.</b>
  - <b>양식에 맞게 결과를 출력한다.</b>

</td><td>

```ruby
def main(name)
    taxRate = getTaxRate()
    pay = calculatePayFor(name, taxRate)
    puts(describeResult(name, pay))
end
```

</td></tr><tr><td>

- 직원의 급여를 계산한다.
    - 사용자로부터 소득세율을 입력받는다.
        - <b>"세율을 입력하세요: "라는 문장을 화면에 출력한다</b>
        - <b>키보드를 통해 세율을 입력받는다</b>
    - 직원의 급여를 계산한다.
    - 양식에 맞게 결과를 출력한다.

</td><td>

```ruby
def getTaxRate()
    print("세율을 입력하세요: ")
    return gets().chomp().to_f()
end
```

</td></tr><tr><td>

- 직원의 급여를 계산한다.
    - 사용자로부터 소득세율을 입력받는다.
        - "세율을 입력하세요: "라는 문장을 화면에 출력한다
        - 키보드를 통해 세율을 입력받는다
    - 직원의 급여를 계산한다.
        - <b>전역 변수에 저장된 직원의 기본급 정보를 얻는다.</b>
        - <b>급여를 계산한다.</b>
    - 양식에 맞게 결과를 출력한다.

</td><td>

```ruby
$employees = ["직원A", "직원B", "직원C"]
$basePays = [400, 300, 250]

def calculatePayFor(name, taxRate)
    index = $employees.index(name)
    basePay = $basePays[index]
    return basePay - (basePay * taxRate)
end
```

</td></tr><tr><td>

- 직원의 급여를 계산한다.
    - 사용자로부터 소득세율을 입력받는다.
        - "세율을 입력하세요: "라는 문장을 화면에 출력한다
        - 키보드를 통해 세율을 입력받는다
    - 직원의 급여를 계산한다.
        - 전역 변수에 저장된 직원의 기본급 정보를 얻는다.
        - 급여를 계산한다.
    - 양식에 맞게 결과를 출력한다.
        - <b>"이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.</b>

</td><td>

```ruby
def describeResult(name, pay)
    return "이름: #{name}, 급여: #{pay}"
end
```

</td></tr></table>

호출 예시 : `main("직원C")`

<br/>

### 하향식 기능 분해의 문제점

1. **비현실적인 시스템은 하나의 메인 함수**

> 실제 시스템에 정상(top) 이란 존재하지 않는다 - 버트란드 마이어

<br/>

2. **메인 함수의 빈번한 재설계**
  - 시스템은 여러 개의 정상으로 구성

<br/>

3. **비즈니스 로직과 사용자 인터페이스의 결합**
  - 비즈니스 로직과 사용자 인터페이스가 변경되는 빈도가 다름 (UI는 자주 변경)
  - 근본적으로 변경에 불안정한 아키텍처를 낳음

<br/>

4. **성급하게 결정된 실행 순서**
  - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하됨
  - 무엇(what)이 아니라 어떻게(how)를 가장 먼저 물어봄

<pre>
<b>기능 분해 방식 → 중앙집중 제어 스타일(centralized control style)의 형태</b>
- 실행 순서나 조건, 반복과 같은 제어 구조를 미리 결정하지 않고는 분해를 진행할 수 없기 때문
- <b>상위 함수</b>에서 중요한 제어 흐름 결정이 이뤄지고, <b>하위 함수</b>는 상위 함수의 흐름에 따라 적절한 시점에 호출
</pre>

- 하향식 설계와 관련된 모든 문제의 원인은 결합도
- 함수는 상위 함수가 강요하는 문맥에 강하게 결합

<br/>

5. **데이터 변경으로 인한 파급효과**
- 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다


**데이터 변경으로 인해 발생하는 함수에 대한 영향도를 파악하는 것이 생각보다 쉽지 않음**

```ruby
$employees = ["직원A", "직원B", "직원C", "아르바이트D", "아르바이트E", "아르바이트F"]
$basePays = [400, 300, 250, 1, 1, 1.5]
$hourlys = [false, false, false, true, true, true]
```

위 데이터는 **아르바이트 직원에 대한 급여도 계산할 수 있도록 시스 템을 개선**해 달라는 요구사항에 `calculateHourlyPayFor`, `hourly`, `calculatePay`, `sumOfBasePays` 함수들을 수정해야 함.

→ ✅ **데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 제공되는 함수만 이용해 데이터에 접근해야 함**

<br/>

### 언제 하향식 분해가 유용한가?

> 하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 방법이다. 
> 그러나 하향식은 새로운 것을 개발하고, 설계하고, 발견하는 데는 적합한 방법이 아니다.
> 
> _- Michael Jackson_

<br/>

### 데이터 추상화
_소프트웨어가 무엇을 알아야 하는지를 추상화_

<br/>

## 03. 모듈

- 모듈은 변경될 가능성이 있는 비밀을 내부로 감추고, 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 한다.
- 외부에서 내부의 비밀에 접근하지 못하도록 커다란 방어막 → **퍼블릭 인터페이스**

**모듈이 감춰야할 두 가지**
- **복잡성**: 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춰야 함
- **변경 가능성**: 변경 발생 시 하나의 모듈만 수정하도록, 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공

<br/>

**각 언어 별 모듈 개념**
- Ruby: `module`
- Java: `package`
- C++, C#: `namespace`

<br/>

### 모듈의 장점

1. **변수 변경 시에도 모듈 내부에만 영향을 미침**
   - 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한할 수 있다.
2. **비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리**
3. **전역 변수와 전역 함수를 제거 → 네임스페이스 오염(namespace pollution)을 방지**
   - 동일한 이름을 다른 모듈에서도 사용 가능 
   - 이름 충돌(name collision)의 위험을 완화

<br/>

좀 더 높은 수준의 추상화를 위해서는 성격이 같은 다양한 종류의 객체를 독립적인 단위로 다룰 수 있어야 함 

다시 말해서 다수의 객체 인스턴스가 존재하는 추상화 메커니즘이 필요
→ 이를 위해 등장한 개념이 **추상 데이터 타입**

<br/>

## 04. 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입


> 프로시저만으로는 충분히 풍부한 추상화의 어휘집을 제공할 수 없다.
> ...
> 추상 데이터 타입은 추상 객체의 클래스를 정의한 것으로 추상 
> 객체에 사용할 수 있는 오퍼레이션을 이용해 규정된다. 
> 추상 데이터 객체를 사용할 때 프로그래머는 오직 객체가 외부에 제공하는 행위에만 관심을 가지며 행위가 구현되는 세부적인 사항에 대해서는 무시한다.
> 객체가 저장소 내에서 어떻게 표현되는지와 같은 구현 정보는 오직 오퍼레이션을 어떻게 구현할 것인지에 집중할 때만 필요하다. 
> 객체의 사용자는 이 정보를 알거나 제공받을 필요가 없다.
> 
> _- Barbara Liskov_

<br/>

**추상 데이터 타입을 구현하기 위한 프로그래밍 언어의 필요한 지원**

- 타입 정의를 선언할 수 있어야 한다.
- 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
- 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
- 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.


오퍼레이션 클러스터(operation cluster)
: 리스코프가 추상 데이터 타입을 정의하기 위해 제시한 언어적인 메커니즘


- 프로그래밍 언어의 관점에서 추상 데이터 타입은 프로그래밍 언어의 내장 데이터 타입과 동일
- 단지 타입을 개발자가 정의할 수 있다는 점이 다를 뿐이다.


> 클래스는 추상 데이터 타입인가?

<br/>

## 05. 클래스

### 클래스는 추상 데이터 타입인가?

| 클래스                                     | 추상 데이터 타입                                                      |
|-----------------------------------------|----------------------------------------------------------------|
| 객체지향 프로그래밍(Object-Oriented Programming) | 추상 데이터 타입 기반의 프로그래밍 패러다임: 객체기반 프로그래밍(Object-Based Programming) |
| 절차를 추상화한 것(procedural abstraction)      | 타입을 추상화한 것(type abstraction)                                   |
| 상속과 다형성 지원                              | 상속과 다형성 지원 X                                                   |
| 오퍼레이션을 기준으로 타입들을 추상화                    | 하나의 대표적인 타입이 다수의 세부적인 타입을 감춤                                   |


**타입 추상화**: 하나의 대표적인 타입이 다수의 세부적인 타입을 감춤
-> 하나의 타입처럼 보이는 Employee 내부에는 정규 직원과 아르바이트 직원이라는 **두 개의 타입이 공존**


<br/>

### 추상 데이터 타입에서 클래스로 변경하기

<table>
<tr>
<th>추상 데이터 타입</th>
<th>Class</th>
</tr><tr>
<td>

```
Employee = Struct.new(:name, :basePay, :hourly, :timeCard) do
    def calculatePay(taxRate)
        if (hourly) then
        return calculateHourlyPay(taxRate)
        end
        return calculateSalariedPay(taxRate)
    end

private
    def calculateHourlyPay(taxRate)
    return (basePay * timeCard) - (basePay * timeCard) * taxRate
    end

    def calculateSalariedPay(taxRate)
      return basePay - (basePay * taxRate)
    end
end
```

</td>
<td>

```
class Employee
    attr_reader :name, :basePay
    def initialize(name, basePay)
        @name = name
        @basePay = basePay
    end
    
    def calculatePay(taxRate)
        raise NotImplementedError
    end

    def monthlyBasePay()
        raise NotImplementedError
    end
end
```

```ruby
class SalariedEmployee < Employee
    def initialize(name, basePay)
        super(name, basePay)
    end

    def calculatePay(taxRate)
        return basePay - (basePay * taxRate)
    end

    def monthlyBasePay()
        return basePay
    end
end
```

```ruby
class HourlyEmployee < Employee
    attr_reader :timeCard
    
    def initialize(name, basePay, timeCard)
        super(name, basePay)
        @timeCard = timeCard
    end
    
    def calculatePay(taxRate)
        return (basePay * timeCard) - (basePay * timeCard) * taxRate
    end
    
    def monthlyBasePay()
        return 0
    end
end
```
</td>

</tr>
</table>

- 일단 객체를 생성하고 나면 객체의 클래스가 무엇인지는 중요하지 않음. 클라이언트의 입장에서는 `SalariedEmployee` 와 `HourlyEmployee` 의 인스턴스를 모두 부모 클래스인 `Employee`의 인스턴스인 것처럼 다룰 수 있음

<br/>

### 변경을 기준으로 선택하라

> "Replace Type Code with Class"
> 
> : 마틴 파울러가 타입을 나타내는 코드를 다형성으로 바꾸는 리팩터링

<br/>

- 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체
- 모든 설계 문제가 그런 것처럼 조건문을 사용하는 방식을 기피하는 이유 역시 변경 때문
- 설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정
- 추상 데이터 타입과 객체지향 설계의 유용성은 설계에 요구되는 변경의 압력이 '타입 추가'에 관한 것인지, 아니면 '오퍼레이션 추가'에 관한 것인지에 따라 달라짐
  - 변경의 압력이 **타입 추가하는 것**이라면 더 강한 경우에는 객체지향
  - 변경의 압력이 **오퍼레이션을 추가하는 것**이라면 추상 데이터 타입



# CHAPTER 10. 상속과 코드 재사용

**TL;DR**

- 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복 (함께 수정할 필요가 없다면 중복이 아님)
- DRY 원칙: '반복하지 마라'라는 뜻의 Don't Repeat Yourself 의 첫 글자를 모아 만든 용어로 간단히 말해 동일한 지식을 중복하지 말라는 것
- 취약한 기반 클래스 문제: 상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상
- 메서드 오버라이딩의 오작용 문제: 클래스 상속을 위해서는 클래스를 설계하고 문서화해야 하며, 그렇지 않은 경우에는 상속을 금지해야함
- 차이에 의한 프로그래밍: 중복 코드를 제거하고 코드를 재사용하는 것
- 상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만듦, 정말로 필요한 경우에만 상속을 사용.

<br/>

## 상속과 중복 코드

- 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복 (함께 수정할 필요가 없다면 중복이 아님)
  - 모양이 유사하다는 것은 단지 중복의 징후일 뿐
- DRY 원칙: '반복하지 마라'라는 뜻의 Don't Repeat Yourself 의 첫 글자를 모아 만든 용어로 간단히 말해 동일한 지식을 중복하지 말라는 것
  - = 한 번, 단 한번(Once and Only Once) 원칙, Beck
  - = 단일 지점 제어(Single Point Control) 원칙, Glass

_demo - v2_

- 요구사항
  - 밤 10시 이전 : Phone (amount, seconds) 
  - 밤 10시 이후 : NightDiscountPhone (nightlyAmount, regularAmount, seconds)


### 중복과 변경

_demo - v2_

- 중복 코드는 새로운 중복 코드를 부름
  - 중복 코드를 제거하지 않은 상태에서 코드를 수정할 수 있는 유일한 방법은 새로운 중복 코드를 추가하는 것뿐


- 요구사항
  - 밤 10시 이전 : Phone (amount, seconds, +taxRate)
  - 밤 10시 이후 : NightDiscountPhone (nightlyAmount, regularAmount, seconds, +taxRate)


<br/>

#### 타입 코드 사용하기

_demo - v3_

- 두 클래스 사이의 중복 코드를 제거하는 한 가지 방법은 클래스를 하나로 합치는 것
- 타입 코드를 사용하는 클래스는 낮은 응집도와 높은 결합도라는 문제에 시달리게 됨


- 요구사항
  - 밤 10시 이전 : Phone (amount, seconds, +taxRate)
  - 밤 10시 이후 : NightDiscountPhone (nightlyAmount, regularAmount, seconds, +taxRate)

<br/>

### 상속을 이용해서 중복 코드 제거하기

_demo - v4_

- NightlyDiscountPhone 클래스가 Phone 클래스를 상속: 코드를 중복시키지 않고도 Phone 클래스의 코드 대부분을 재사용

<pre>
심야 할인 요금제의 규칙 예시

For Example) 
- 밤 10시 이전 : 10초당 5원( regularAmount = 5원, seconds = 10초) 
- 밤 10시 이후 : 10초당 2원( nightlyAmount = 2원, seconds = 10초)
- 가입자가 두 번 통화; 각 통화시간: 40초, 50초

<b>각 통화가 10시 이전</b>
-> (40초/10초 * 5원) + (50초/10초 * 5원) = 45원

<b>각 통화가 10시 이후</b>
-> (40초/10초 * 2원) + (50초/10초 * 2원) = 18원

<b>40 초 동안은 10 시 이전, 50 초 동안은 10 시 이후</b>
-> (40초/10초 * 5원) + (50/10초 * 2원) = 30원
</pre>
<br/>

**다른 계산 법**

`(40초/10초 * 5원) + (50초/10초 * 5원) – (50초/10초 * (5원-2원)) = 30원`

1. 40 초와 50 초 모두에 대해 10 시 이전 기준으로 요금을 계산
2. 10시 이전 기본 요금(5원)에서 10시 이후 기본 요금(2원)을 빼서 차이값 계산
3. 앞의 값에서 뒤의 값을 빼주면 요금을 구할 수 있음

- 기대한 것은 10 시 이전의 요금에서 10 시 이후의 요금을 차감하는 것이 아니라 10 시 이전의 요금과 10 시 이후의 요금을 더하는 것
- 어렵게 만들뿐만 아니라 직관에도 어긋날 수 있음

<br/>

### 강하게 결합된 Phone과 NightlyDiscountPhone

- NightlyDiscountPhone 을 Phone 의 자식 클래스로 만든 이유는 Phone 의 코드를 재사용하고 중복 코드를 제거하기 위함
- 하지만 세금을 부과하는 로직을 추가하기 위해 Phone 을 수정할 때 유사한 코드를 NightlyDiscountPhone 에도 추가해야 함 
- 다시 말해서 코드 중복을 제거하기 위해 상속을 사용했음에도 세금을 계산하는 로직을 추가하기 위해 새로운 중복 코드를 만들어야 하는 것

<br/>

## 취약한 기반 클래스 문제
- 상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상
- 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어


<img src="./image/image1.png" width="1950"/>



```java
Properties properties = new Properties();
properties.setProperty("Bjarne Stroustrup", "C++");
properties.setProperty("James Gosling", "Java");
properties.put("Dennis Ritchie", 67);

assertEquals("C", properties.getProperty("Dennis Ritchie")); // 에러!
```

- `"Dennis Ritchie"` 라는 키의 값으로 **67**을 넣는데 성공했음에도 불구하고,
- `"Dennis Ritchie"` 를 키로 검색할 경우 `null` 반환
- Properties 의 getProperty 메서드가 반환할 값의 타입이 `String`이 아닐 경우 `null`을 반환

**단순히 코드 재사용을 위해 상속을 이용하는 것이 얼마나 위험한지를 잘 보여줌**


<br/>

### 메서드 오버라이딩의 오작용 문제
클래스가 상속되기를 원한다면 상속을 위해 클래스를 설계하고 문서화해야 하며, 그렇지 않은 경우에는 상속을 금지시켜야 한다고 주장

<br/>

### 부모 클래스와 자식 클래스의 동시 수정 문제
결과적으로, 슈퍼클래스의 작성자가 확장될 목적으로 특별히 그 클래스를 설계하지 않았다면 서브클래스는 슈퍼클래스와 보조를 맞춰서 진화해야 함.

<br/>

## Phone 다시 살펴보기

### 추상화에 의존하자

**필자의 코드 중복 제거를 위한 상속을 도입 시 따르는 두 가지 원칙**

- 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 
  - 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
- 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 
  - 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.

<br/>

### 차이를 메서드로 추출하라

_demo - v5_

<br/>

### 중복 코드를 부모 클래스로 올려라

_demo - v6_

### 추상화가 핵심이다

### 의도를 드러내는 이름 선택하기

_demo - v6_

### 세금 추가하기

_demo - v7_

- 부모 클래스에 추가된 인스턴스 변수는 자식 클래스의 초기화 로직에 영향을 미침 
- 결과적으로 책임을 아무리 잘 분리하더라도 인스턴스 변수의 추가는 종종 상속 계층 전반에 걸친 변경을 유발
- 하지만 인스턴스 초기화 로직을 변경하는 것이 두 클래스에 동일한 세금 계산 코드를 중복시키는 것보다는 현명한 선택

<br/>


## 차이에 의한 프로그래밍

- 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법
- 상속을 이용하면 이미 존재하는 클래스의 코드를 쉽게 재사용할 수 있기 때문에 애플리케이션의 점진적인 정의(incremental definition)가 가능해짐
- 차이에 의한 프로그래밍의 목표는 중복 코드를 제거하고 코드를 재사용하는 것

> 상속이 코드 재사용이라는 측면에서 매우 강력한 도구인 것은 사실이지만,
> 강력한 만큼 잘못 사용할 경우에 돌아오는 피해 역시 크다는 사실을 뼈저리 게 경험한 것이다. 
> 
> 상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만든다. 
> 정말로 필요한 경우에만 상속을 사용하라.










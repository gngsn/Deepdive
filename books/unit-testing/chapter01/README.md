# CHAPTER 1. 단위 테스트의 목표

**TL;DR**
- **성공적인 테스트 스위트**
  - 1#. 개발 주기에 통합되어 있음
  - 2#. 코드베이스에서 가장 중요한 부분 - _비즈니스 로직 (도메인 모델)_ - 만을 대상으로 함
  - 3#. 최소 유지비로 최대 가치를 끌어냄 (**가치 있는 테스트를 식별하고, 작성하라**)
- **비용 편익 분석**을 배우고 **안티 패턴**을 피하는 방법을 배워라.
  - **비용 편익 분석 (cost-benefit analysis)**: 여러 가지 대안에 대해 비용과 이익을 분석해서 가장 효과적인 대안을 찾는 방법론.
  - **안티 패턴(anti-pattern)**: 처음에는 괜찮은 것 같지만 미래에 문제를 야기하는 패턴
- 테스트의 장점
  - **소프트웨어 엔트로피(software entropy)** 를 막을 수 있음
    - 지속적인 정리와 리팩터링 등 적절한 관리를 하지 않고 방치하면 시스템이 점점 더 복잡해지고 무질서해짐.
    - 소프트웨어 품질을 떨어뜨리는 코드의 형태.
  - **회귀(regression)에 대한 보험을 제공**
    - **소프트웨어 버그**와 **회귀**는 동의어
**테스트의 가치와 유지 비용을 모두 고려해야 함**
  - 기반 코드를 리팩터링할 때 **테스트도 리팩터링**하라
  - 각 **코드 변경 시 테스트를 실행**하라
  - **테스트가 잘못된 경고를 발생시킬 경우 처리**하라
  - 기반 코드의 동작을 이해하려고 할 때는 **테스트를 읽는 데 시간을 투자**하라
- 테스트도 **애플리케이션의 정확성을 보장**을 목표하는 **코드베이스**의 일부로 봐야 함
- $`코드\ 커버리지\ (테스트\ 커버리지) = \frac{제품\ 코드\ 라인\ 수}{전체\ 라인\ 수}`$
- $`분기\ 커버리지 = \frac{통과\ 분기}{전체\ 분기\ 수}`$
- **커버리지 지표에 관한 문제점**
  - 1#. 가능한 모든 결과를 검증한다고 보증할 수 없음
  - 2#. 외부 라이브러리 코드 경로를 고려할 수 없음
- **시스템의 핵심 부분은 커버리지를 높게 두는 것이 좋지만, 이 높은 수준을 요구 사항으로 삼는 것은 좋지 않음.**


<br/><br/>

---

<br/>


- 단위 테스트에 시간을 투자할 때는 항상 최대한 이득을 얻도록 노력해야 하고, 테스트에 드는 노력을 가능한 한 줄이고 그에 따르는 이득을 최대화해야 함
- 비용 편익 분석 (cost-benefit analysis)을 배우고 안티 패턴(anti-pattern)을 피하는 방법을 배워라
  - **비용 편익 분석 (cost-benefit analysis)**: 여러 가지 대안에 대해 비용과 이익을 분석해서 가장 효과적인 대안을 찾는 방법론
  - **안티 패턴(anti-pattern)**: 처음에는 괜찮은 것 같지만 미래에 문제를 야기하는 패턴

<br/>

## 1.1 단위 테스트 현황 

**️✔️ 단위 테스트의 상태**

- 제품 코드 (production application)와 테스트 코드 (test code) 의 비율은 `1:1`에서 `1:3` 이지만, 때로는 `1:10` 수준에 이르기도 함
  - `production code : test code = 1 : 3`

<br/>

**기업용 애플리케이션**의 특징
- 높은 비즈니스 복잡도
- 긴 프로젝트 수명
- 중간 크기의 데이터
- 낮은 수준이나 중간 수준 정보의 성능 요구

<br/>

## 1.2 단위 테스트 목표

코드 조각을 단위 테스트하는 것은 뚜렷하게 파악할 수 있는 잣대
- 괜찮은 부정 지표. 비교적 높은 정확도로 저품질 코드를 가려냄

- **단위 테스트하기 어려운 코드**는 반드시 개선이 필요함을 암시
  - 보통 **강결합(tight coupling)** 에서 **저품질** 성향: 서로 충분히 분리되지 않았기 때문
  - 너무 낮은 결합도를 보여도 문제가 될 수 있음

<br />

**소프트웨어 엔트로피(software entropy)**: 시스템 내의 "무질서"
- 개발 속도가 빠르게 감소하는 현상
- 코드베이스에서 무언가를 변경할 때마다 엔트로피 또한 증가. 소프트웨어에서 엔트로피는 품질을 떨어뜨리는 코드의 형태
- 지속적인 정리와 리팩터링 등 적절한 관리를 하지 않고 방치하면 시스템이 점점 더 복잡해지고 무질서해짐

<br/>

#### 테스트 특징 
- 소프트웨어 엔트로피를 막을 수 있음
- 회귀 (regression)에 대한 보험을 제공하는 도구
- 새로운 기능을 도입하거나 새로운 요구 사항에 더 잘 맞게 리팩터링한 후에도 기존 기능이 잘 작동하는지 확인하는 데 도움이 됨
  - 회귀: 특정 사건 (일반적으로 코드 수정) 후에 기능이 의도한 대로 작동하지 않는 경우. 소프트웨어 버그와 회귀라는 용어는 동의어이며 바꿔서 사용할 수 있음
- 테스트는 초반에 어쩌면 상당한 노력이 필요

<br/>

#### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

**테스트의 가치와 유지 비용을 모두 고려해야 함**
- 기반 코드를 리팩터링할 때 테스트도 리팩터링하라
- 각 코드 변경 시 테스트를 실행하라
- 테스트가 잘못된 경고를 발생시킬 경우 처리하라
- 기반 코드가 어떻게 동작하는지 이해하려고 할 때는 테스트를 읽는 데 시간을 투자하라

<br/>

**제품 코드 vs 테스트 코드**

- 코드는 자산이 아니라 **책임**
- 테스트도 **애플리케이션의 정확성을 보장**을 목표하는 **코드베이스**의 일부로 봐야 함
- 다른 코드와 마찬가지로 **단위 테스트도 버그에 취약하고 유지 보수가 필요**

<br/>

### 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

- **커버리지 지표**: 테스트 스위트가 소스 코드를 얼마나 실행하는지를 백분율로 나타냄

- 커버리지 지표는 괜찮은 부정 지표지만, 좋지 않은 긍정 지표

<br/>

#### 1.3.1 코드 커버리지 지표에 대한 이해

- **코드 커버리지(code coverage)**: = 테스트 커버리지 (test coverage).

<br/>

$$코드\ 커버리지\ (테스트\ 커버리지) = \frac{제품\ 코드\ 라인\ 수}{전체\ 라인\ 수}$$

<br/>

#### 1.3.2 분기 커버리지 지표에 대한 이해

**분기 커버리지(code coverage)**
- 원시 코드 라인 수를 사용하는 대신 if 문과 switch 문과 같은 제어 구조에 중점을 둠
- 분기 개수만 다루며, 해당 분기를 구현하는 데 얼마나 코드가 필요한지 고려하지 않음

<br/>

$$분기\ 커버리지 = \frac{통과\ 분기}{전체\ 분기\ 수}$$

<br/><br/>

<table> 
<tr><th></th><th colspan="2">Production Code</th><th>Test Code</th></tr>
<tr><th>Code</th><td>
<pre><code lang="c">public static bool IsStringLong(string input)
{
  if (input.length > 5) 
    return true;
  return false;
}
</code></pre>
</td>
<td>
<pre><code lang="c">public static bool IsStringLong(string input)
{
  return input.length > 5;
}
</code></pre>
</td>
<td>
<pre><code lang="c">public void Test()
{
  bool result = IsStringLong("abc"); 
  Assert.Equal(false, result);
}
</code></pre></td>
</tr><tr>
<th>Code Coverage</th>
<td> $$Code\ Coverage = \frac{4}{5} = 0.8 = 80\%$$ </td>
<td> $$Code\ Coverage = \frac{3}{3} = 1 = 100\%$$ </td>
<td> - </td>
</tr><tr>
<th>Branch Coverage</th>
<td> $$Branch\ Coverage = \frac{1}{2} = 0.5 = 50\%$$ </td>
<td> $$Branch\ Coverage = \frac{1}{2} = 0.5 = 50\%$$ </td>
<td> - </td>
</tr>
</table>

<br/>

#### 1.3.3 커버리지 지표에 관한 문제점

테스트 스위트의 품질을 결정하는 데 어떤 커버리지 지표도 의존할 수 없는 두 가지 이유

<br/> 

**✔️ 1#. 가능한 모든 결과를 검증한다고 보증할 수 없음**

모든 기반 코드를 테스트했다고 보증할 수 없음

- EX 1) 일부분인 결과 값 만을 검증하는 테스트 코드
- EX 2) 검증이 없는 테스트 코드

<br/> 

**✔️ 2#. 외부 라이브러리 코드 경로를 고려할 수 없음**

외부 라이브러리가 통과하는 코드 경로를 고려하지 않음

```asp
public static int Parse(string input)
{
  return int.Parse(input);
}
```

```asp
public void Test(string input)
{
  int result = Parse("5");
  Assert.Equal(5, result);
}
```

<br/> 

`.NET`의 `int.Parse` 메서드는 내부에 숨겨진 분기 로직이 포함됨

- null / empty string / no integer / too long string 

수 많은 예외 상황 (edge case)에 빠질 수 있지만, 모든 예외 상황을 다루는지 확인할 방법이 없음

<br/>

#### 1.3.4 특정 커버리지 숫자를 목표로 하기 

⭐️시스템의 핵심 부분은 커버리지를 높게 두는 것이 좋음. 
하지만, 이 높은 수준을 요구 사항으로 삼는 것은 좋지 않음.

<br/>

### 1.4 무엇이 성공적인 테스트 스위트를 만드는가?

**1. 개발 주기에 통합되어 있음**

이상적으로는 코드가 변경될 때마다 아무리 작은 것이라도 실행되어야 함

<br/>

**2. 코드베이스에서 가장 중요한 부분만을 대상으로 함**

시스템의 가장 중요한 부분 - 대부분의 비즈니스 로직 (도메인 모델) -에 단위 테스트 노력을 기울이고, 다른 부분은 간략하게 또는 간접적으로 검증하는 것이 좋음.
비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있음

- 인프라 코드
- 데이터베이스나 서드파티 시스템과 같은 외부 서비스 및 종속성
- 모든 것을 하나로 묶는 코드

도메인 모델에 초첨을 둬라. 도메인 모델을 코드베이스 중 중요하지 않은 부분과 분리해라. 

<br/>

**3. 최소 유지비로 최대 가치를 끌어냄**

최소 유지비로 최대 가치를 달성하라. - **가치 있는 테스트를 식별하고, 작성하라.**


**단위 테스트의 목표를 달성하기 위한 유일한 방법**
- 좋은 테스트와 좋지 않은 테스트를 구별하는 방법을 배운다
- 테스트를 리팩터링해서 더 가치있게 만든다


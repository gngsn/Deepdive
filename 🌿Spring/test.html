<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">탐색적 테스팅 exploratory testing 은 테스트 대상을 고장내야할 퍼즐로 생각한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">기본적으로 창의력을 요구하는 작업이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">의외의 데이터를 입력하거나 예상치 못한 절차로 조작하여 망가뜨리려 시도한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 자동 테스트는 소프트웨어를 변경할 수 있게 해주는 토대입니다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 테스트를 확장하려면 반드시 자동화해야 합니다. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 테스트 커버리지를 건실하게 유지하려면 균형 잡힌 테스트 스위트가 필요합니다. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- &ldquo;네가 좋아했다면 테스트를 준비해뒀어야지.&rdquo; </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 조직의 테스트 문화를 바꾸는 데는 시간이 걸립니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">구글이 테스트를 분류하는 두 가지 주요 축은 '크기'와 '범위'이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">'크기 size'는 테스트가 소비하는 자원과 수행할 수 있는 작업을 뜻하며, </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">'범위 scope'는 테스트가 검증하고자 하는 코드의 양을 의미한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;"> 테스트 크기의 정의는 명확하지만 범위는 다소 모호한 면이 있다. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">구글에서 말하는 단위 테스트 unit test 는 단일 클래스나 메서드처럼 범위가 상대적으로 좁은 테스트를 뜻한다. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">단위 테스트는 일반적으로 크기가 작은데, 사실 반드시 그런 것만은 아니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';">Unit Tests Properties</span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';">- 대체로 작은 테스트로, 빠르고 결정적 deterministic이기때문에 수시로 수행하며 피드백을 즉각 얻을 수 있다.</span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';">- 대체로 대상 코드와 동시에 작성할 수 있을 만큼 작성하기 쉽다. </span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';">- 기존 동작을 망가뜨리지 않게끔 커버러지를 높일 수 있다.</span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';">- 간단한 개념이며 시스템의 특정 부분에 집중적인 코드이기 때문에 실패 시 원인을 파악하기 쉽다.</span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';">- 테스트 대상의 사용법과 의도 동작 방식을 알려주는 문서자료나 예제 코드 역할을 해준다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;"><span style="color: #000000;">구글은 유지보수성을 상당히 중요시하는데, 유지 보수하기 쉬운 테스트란 'just work, 그냥 동작하는' 테스트를 의미한다.</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;"><span style="color: #000000;">한 번 작성해두면 실패하지 않는 한 신경쓸 필요가 없고, 실패해도 명확하게 이유로 버그를 찾을 수 있다는 의미다.&nbsp;</span></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;">Maintainability</span></h3>
<p data-ke-size="size14"><span style="font-family: 'Noto Sans Light'; color: #666666;"><b><i>TL;DRs </i></b></span></p>
<p data-ke-size="size14"><span style="font-family: 'Noto Sans Light'; color: #666666;"><i>본 섹션에서는 유지가능성의 중요함을 다룬다.</i></span></p>
<p data-ke-size="size14"><span style="font-family: 'Noto Sans Light'; color: #666666;"><i>메인 코드가 변경되어도 테스트 코드가 변경되지 않는 팁으로 <b>쉽게 깨지지 않는</b>, <b>명확한 코드</b>&nbsp;작성을 제안한다.</i></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<blockquote data-ke-style="style2"><span style="font-family: 'Noto Sans Light'; color: #666666;">Mary는 간단한 기능 하나를 추가하려고 하는데, 코드 10줄 정도면 충분하여 순식간에 구현할 수 있었다. </span><br /><span style="font-family: 'Noto Sans Light'; color: #666666;">그런데 체크인하려 하자 자동 테스트 시스템이 화면 가득 오류를 보내왔다.</span><br /><br /><span style="font-family: 'Noto Sans Light'; color: #666666;">Mary는 하나하나 실패 테스트들을 해결하느라 남은 하루를 다 허비했다. 각각의 테스트 케이스 마다 실패 이유는 진짜 버그가 아니었다. 테스트하려는 코드의 내부 구조가 특정한 형태일 때만을 가정하였는데, 그 부분이 깨져서 테스트 코드를 변경해야 하는 것이었다. </span><br /><br /><span style="font-family: 'Noto Sans Light'; color: #666666;">문제는 테스트 코드는 대부분 무엇을 검증하려는지가 한눈에 들어오지 않았다. 게다가 이 문제를 해결하려고 추가한 코드 때문에 나중에 이 테스트를 들여다볼 사람이 로직을 이해하기가 더 어려워졌다. </span><br /><br /><span style="font-family: 'Noto Sans Light'; color: #666666;">결국 금방 끝나야 했을 작업 하나 때문에 Mary는 며칠을 허비하며 생산성과 사기가 크게 떨어졌다.</span></blockquote>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">이 문제에서 테스트가 정반대의 효과를 냈다. 하지만 주변에서 흔히 볼 수 있는 문제이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">이 문제를 해결할 만병통치약은 없지만, 구글에서는 해결할 다양한 패턴과 관행을 발굴하고 공유하여 권장해오고 있다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">위의 내용에서는 두 가지를 문제로 삼을 수 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">첫째, 버그도 검증 대상과도 관련없는 '깨지기 쉬운 Brittle' 테스트</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">둘째, 원인을 찾기 어려운 '불명확한 unclear' 테스트</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">이 두 문제점을 기반으로 어떻게 코드를 짜야할지에 대한 권장 사항들을 알아보자.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><span style="font-family: 'Noto Sans Light'; color: #000000;">Preventing Brittle Tests</span></h2>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><span style="font-family: 'Noto Sans Light'; color: #000000;"><b>Brittle Tests</b></span></p>
<p data-ke-size="size14"><span style="color: #000000; font-family: 'Noto Sans Light';">깨지기 쉬운 테스트</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">: 실제로 버그는 없지만, 검증 대상 코드와는 관련조차 없는 변경 때문에 실패하는 테스트</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Sans Light'; color: #000000;">변경되지 않게 하자</span></h3>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">메인 코드의 변경에 따라 변경되지 않는 테스트를 작성하기 위해서는,</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;"><b>메인 코드가 변경되는 유형</b>을 생각해보면서 <b>각 유형 별로 테스트</b>를 어떻게 가져가야할지 따져봐야 한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;">✔️ <span style="color: #9d9d9d; font-family: 'Noto Sans Light';">when</span> Pure refactorings</span></h4>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">인터페이스의 수정없이 내부만을 리팩터링한다면 테스트는 변경되면 안된다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">이 때 테스트의 역할은 <b>해당 기능의 행위가 달라지지 않음을 보장</b>하는 것이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">만약 테스트를 변경할 상황이 생긴다면, </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">기능의 행위가 변경되었거나 테스트 추상화 수준이 적절하지 않음을 나타낸다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="color: #000000; font-family: 'Noto Sans Light';">✔️ <span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;"><span style="color: #9d9d9d; font-family: 'Noto Sans Light';">when</span></span><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;">&nbsp;</span><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR';">New features</span></span></h4>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';">새로운 기능은 기존 테스트에 영향을 주면 안된다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';"><b>새 기능 당 새로운 테스트</b>를 작성해야 한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">만약 테스트를 변경할 상황이 생긴다면, </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">다른 기능에 의도치 않은 영향을 기쳤거나 테스트 자체에 문제가 있음을 나타낸다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="color: #000000; font-family: 'Noto Sans Light';">✔️ <span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;"><span style="color: #9d9d9d; font-family: 'Noto Sans Light';">when</span></span><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;">&nbsp;</span><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR';">Bug fixes</span></span></h4>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';">새로운 기능과 비슷하게, 버그가 발생했다는 것은 기존 test suite에 빠진 기능이 있고, <b>해당 케이스를 놓쳤기 때문</b>이다.</span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';">따라서 누락된 케이스를 추가해야 한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="color: #000000; font-family: 'Noto Sans Light';">✔️ <span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;"><span style="color: #9d9d9d; font-family: 'Noto Sans Light';">when</span></span><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;">&nbsp;</span><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR';">Behavior changes</span></span></h4>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">기존 기능을 변경하는 경우로, 기존 테스트도 함께 변경되어야 한다. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">이 때에는 위와 달리 '위도치 않게' 변경하는 것이 아니라 </span><b>'의도적으로' 변경</b><span style="color: #000000; font-family: 'Noto Sans Light'; letter-spacing: 0px;">하는 것이다. </span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light'; letter-spacing: 0px;">시스템을 망가뜨리지 않게, 혹은 애초부터 변경할 일이 없게 설계하려고 노력해야 한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Sans Light'; color: #000000;">Public API를 사용하자</span></h3>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657116996331" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public void processTransaction(Transaction transaction) {
  if (isValid(transaction)) {
    saveToDatabase(transaction);
  }
}

private boolean isValid(Transaction t) {
  return t.getAmount() &lt; t.getSender().getBalance();
}

private void saveToDatabase(Transaction t) {
  String s = t.getSender() + "," + t.getRecipient() + "," + t.getAmount();
  database.put(t.getId(), s);
}

public void setAccountBalance(String accountName, int balance) {
  // Write the balance to the database directly
}

public void getAccountBalance(String accountName) {
  // Read transactions from the database to determine the account balance
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">위와 같은 코드를 테스트 할 때 아래와 같이 private으로 되어있는 메서드에 접근하고 싶은 유혹이 생길 것이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657117058356" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void emptyAccountShouldNotBeValid() {
  // private method인 isValid 에 접근
  assertThat(processor.isValid(newTransaction().setSender(EMPTY_ACCOUNT)))
      .isFalse();
}

@Test
public void shouldSaveSerializedData() {
  // private method인 saveToDatabase에 접근
  processor.saveToDatabase(newTransaction()
      .setId(123)
      .setSender("me")
      .setRecipient("you")
      .setAmount(100));
  assertThat(database.get(123)).isEqualTo("me,you,100");
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">이런 테스트 케이스를 짜게 되면 내부 메서드를 조금만 수정해도 금방 깨지게 될 것이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">하지만 아래와 같이 <b>public API</b>만을 사용해서 같은 수준의 테스트 커러비지를 달성할 수 있다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657117280322" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void shouldTransferFunds() {
  processor.setAccountBalance("me", 150);
  processor.setAccountBalance("you", 20);

  processor.processTransaction(newTransaction()
      .setSender("me")
      .setRecipient("you")
      .setAmount(100));

  // me(150) --[100]--&gt; you(20): me(50), you(120)
  assertThat(processor.getAccountBalance("me")).isEqualTo(50);
  assertThat(processor.getAccountBalance("you")).isEqualTo(120);
}

@Test
public void shouldNotPerformInvalidTransactions() {
  processor.setAccountBalance("me", 50);
  processor.setAccountBalance("you", 20);

  processor.processTransaction(newTransaction()
      .setSender("me")
      .setRecipient("you")
      .setAmount(100));

  // me(50) --[100]--&gt; you(20): me(50), you(20) &lt;= not perform
  assertThat(processor.getAccountBalance("me")).isEqualTo(50);
  assertThat(processor.getAccountBalance("you")).isEqualTo(20);
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">Public API를 사용하면 <b>정의상 대상 시스템을 사용자와 똑같은 방식으로 사용</b>한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">그래서 더 현실적이고 잘깨지지 않는다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">Public API 를 구별하는 정의는 없지만, 구글의 경험 상 그 법칙은 아래와 같다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR';">✔️ <span style="color: #000000;">보조 클래스는&nbsp;테스트 X</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">: 보조의 용도(헬퍼 클래스)라면 독립된 단위로 생각하지 않는게 좋다. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">해당 클래스가 보조하는 클래스를 우회적으로 테스트하는 것이 좋다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR';">✔️ 누구든 접근할 수 있으면 테스트 O</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">: 누구든 접근할 수 있는 패키지 혹은 클래스는 거의 예외없이 직접 사용자와 똑같은 방식으로 접근하는 테스트를 하는 것이 좋다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR';">✔️ 넓은 범위라면 중복이 되더라도 테스트 O</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">: 넓은 범위로 기능을 제공하는 패키지나 클래스(support library)도 직접 테스트하는 단위로 보자. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">중복이 될 수 있지만, 유익한 중복이다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Sans Light'; color: #000000;">Test State, Not Interactions</span></h3>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;">State testing </span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';">: you observe the system itself to see what it looks like after invoking with it. </span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Noto Sans Light';"><span style="color: #000000;">메서드 호출 후 발생하는 결과 자체를 확인</span></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><span style="font-family: 'Noto Sans Demilight', 'Noto Sans KR'; color: #000000;">Interaction testing</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">: you instead check that the system took an expected sequence of actions on its collaborators in response to invoking it. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;"><span style="color: #000000;">입력한 값에 대해 그 호출 값을 불러오며 사용되는 기능이 잘 수행하는지 확인</span></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size14"><span style="color: #9d9d9d;"><span style="font-family: 'Noto Sans Light';">번역이 어색해서 추가하자면 </span><span style="font-family: 'Noto Sans Light';">State는 메서드를 호출 결과값의 상태를 체크하고, </span></span></p>
<p data-ke-size="size14"><span style="color: #9d9d9d;"><span style="font-family: 'Noto Sans Light';">Interaction은 테스트와 관련된 호출 메서드가 잘 동작하는지 확인한다.</span></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<div style="display: flex;">[##_Image|kage@bSJCtH/btrGIw6gxKt/Kon3Y8hAQuKzpd5sPR6NfK/img.png|CDM|1.3|{"originWidth":936,"originHeight":466,"style":"alignCenter","width":372,"height":185,"caption":"Brittle interaction test"}_##][##_Image|kage@cbJoWU/btrGGc0ZqDW/kpMUtWz3plwEFzWJhp7ec1/img.png|CDM|1.3|{"originWidth":1084,"originHeight":466,"style":"alignCenter","width":488,"height":210,"caption":"Testing against state"}_##]</div>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">1) Brittle interaction test</span></p>
<pre id="code_1657118171881" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void shouldWriteToDatabase() {
  accounts.createUser("foobar");
  verify(database).put("foobar");
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">2) Testing against state</span></p>
<pre id="code_1657118181727" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void shouldCreateUsers() {
  accounts.createUser("foobar");
  assertThat(accounts.getUser("foobar")).isNotNull();
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">1)에서는 특정 API가 호출되었는지를 확인한다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">만약, 리팩터링이 되거나 쓰이고 나서 버그로 인해 데이터가 삭제되어도 통과할 것이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">2)는 호출 후 어떤 상태인지를 판단하며, 관심사를 더 명확하게 표현하고 있다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><span style="font-family: 'Noto Sans Light'; color: #000000;">Writing Clear Tests</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- Complete and Concise</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- Test Behaviors (Not Methods)</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">&nbsp; - Structure tests to emphasize behaviors 행위가 부각되도록 구성하자</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">&nbsp; - Name tests after the behavior being tested</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">&nbsp;&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- Don't Put Logic</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- Clear Failure Message</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Sans Light'; color: #000000;">Make Your Tests Complete and Concise</span></h3>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">Complete test 완전한 테스트 :&nbsp;읽는 이가 이해하는데 필요한 모든 정보를 본문에 담고 있는 테스트</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">Concise test 간결한 테스트 :&nbsp;코드가 산만하지 않고 관련없는 정보는 포함하지 않은 테스트</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">아래는 이 두가지를 모두 못지킨 예시</span></p>
<pre id="code_1657119445563" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void shouldPerformAddition() {
  Calculator calculator = new Calculator(new RoundingStrategy(), 
      "unused", ENABLE_COSINE_FEATURE, 0.01, calculusEngine, false);
  int result = calculator.calculate(newTestCalculation());
  assertThat(result).isEqualTo(5); // Where did this number come from?
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">입력 값의 의미를 명확하게 바꿔주고, 계산기 생성과 관련없는 내용은 숨겨주어 명확하게 만들어보자.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657119515499" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void shouldPerformAddition() {
  Calculator calculator = newCalculator();
  int result = calculator.calculate(newCalculation(2, Operation.PLUS, 3));
  assertThat(result).isEqualTo(5);
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Sans Light'; color: #000000;">Test Behaviors, Not Methods</span></h3>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">행위 주도 테스트Behavior-driven tests는 대체로 메서드 중심 테스트Method-oriented tests보다 명확하다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">그 이유는 아래와 같이 세 가지 정도 들 수 있다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">1/ 자연어에 더 가깝기 때문에 더 자연스럽게 이해할 수 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">2/ 테스트 각각이 더 좁은 범위를 검사하기 때문에 원인과 결과가 더 분명하게 드러난다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">3/ 각 테스트는 짧고 서술적이기 때문에 검사한 기능이 무엇인지 파악하는 게 쉽다. 덕분에 다른 엔지니어가 기존 메서드에 코드를 추가하지piling 않고 새로운 메서드를 추가하게끔 이끈다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">많은 개발자들이 메서드 하나에 테스트 메서드 하나씩 두려고Method-oriented tests 한다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">가령 아래와 같은 메서드를 정의했다고 해보자.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657180508919" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public void displayTransactionResults(User user, Transaction transaction) {
  ui.showMessage("You bought a " + transaction.getItemName());
  if (user.getBalance() &lt; LOW_BALANCE_THRESHOLD) {
    ui.showMessage("Warning: your balance is low!");
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">그럼 아래와 같은 테스트 코드를 짜려고 할 것이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre class="java" data-code-language="java" data-type="programlisting" data-ke-language="java"><code>@Test
public void testDisplayTransactionResults() {
  transactionProcessor.displayTransactionResults(
      newUserWithBalance(
          LOW_BALANCE_THRESHOLD.plus(dollars(2))),
      new Transaction("Some Item", dollars(3)));

  assertThat(ui.getText()).contains("You bought a Some Item");
  assertThat(ui.getText()).contains("your balance is low");
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">이렇게 메서드 하나를 검사하다보면 불명확한 테스트로 이어지는 문제가 발생한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">테스트를 메서드 별로 작성하지 말고, 아래와 같이 행위별로 작성하는 방법을 추천한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657181940077" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void displayTransactionResults_showsItemName() {
  transactionProcessor.displayTransactionResults(
      new User(), new Transaction("Some Item"));
  assertThat(ui.getText()).contains("You bought a Some Item");
}

@Test
public void displayTransactionResults_showsLowBalanceWarning() {
  transactionProcessor.displayTransactionResults(
      newUserWithBalance(
          LOW_BALANCE_THRESHOLD.plus(dollars(2))),
      new Transaction("Some Item", dollars(3)));
  assertThat(ui.getText()).contains("your balance is low");
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">결과적으로 위와 같이 변경할 수 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">테스트를 쪼개느라 코드가 늘어났지만, 훨씬 명확하다는 가치가 있다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">행위란 특정 상태인 해당 시스템이 입력에 대해서 어떻게 반응할지에 대한 어떠한 보증guarantee과 같다.</span></p>
<p data-ke-size="size14"><span style="font-family: 'Noto Sans Light'; color: #000000;">입력 값에 대한 결과값을 예상할 수 있는 것을 '보증'할 수 있는 것으로 표현한 듯 합니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">행위를 표현하는 방법에는 대표적으로&nbsp;<a style="color: #000000;" href="https://martinfowler.com/bliki/GivenWhenThen.html">"given", "when", "then"</a>이 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">가령, 아래와 같이&nbsp;표현할 수 있다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<blockquote data-ke-style="style2"><span style="font-family: 'Noto Sans Light'; color: #000000;">(given) 은행 잔고가 빈 상태에서</span><br /><span style="font-family: 'Noto Sans Light'; color: #000000;">(when) 돈을 인출하려하면</span><br /><span style="font-family: 'Noto Sans Light'; color: #000000;">(then) 거래를 거부한다.&nbsp;</span></blockquote>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">모든 행위는 given, when, then이라는 세 요소로 구성된다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">given : 설정 정의</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">when : 시스템이 수행할 작업을 정의</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">then : 결과를 검증</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">이 요소들이 명확히 드러나는 구조라면 명확하고 깔끔한 테스트라고 할 수 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">그래서 <a style="color: #000000;" href="https://Cucumber.io" target="_blank" rel="noopener">Cucumber</a>이나 <a style="color: #000000;" href="https://spockframework.org" target="_blank" rel="noopener">Spock</a> 처럼 given/when/then을 지원하는 프레임워크도 생겼다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p>[##_Image|kage@ngb7v/btrGKoZYohN/bJXCZ4CEcKw7X23slAEOFk/img.png|CDM|1.3|{"originWidth":882,"originHeight":385,"style":"alignCenter","width":446,"height":198,"caption":"Cucumber.io","filename":"blob"}_##]</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">이렇게 테스트 코드를 작성하게 되면 아래 세 단계의 깊이로 점차 자세하게 파악할 수 있다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">기본적으로 아래와 같이 주석을 통해 간단히 명시하는 것이 좋다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657184105437" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void transferFundsShouldMoveMoneyBetweenAccounts() {
  // Given two accounts with initial balances of $150 and $20
  Account account1 = newAccountWithBalance(usd(150));
  Account account2 = newAccountWithBalance(usd(20));

  // When transferring $100 from the first to the second account
  bank.transferFunds(account1, account2, usd(100));

  // Then the new account balances should reflect the transfer
  assertThat(account1.getBalance()).isEqualTo(usd(50));
  assertThat(account2.getBalance()).isEqualTo(usd(120));
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">행위 중점일 때 세 단계를 통해 테스트를 자세히 이해해 나갈 수 있다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">1. 메서드의 이름으로 검사 행위를 간략하게 파악</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">2. 행위를 형식화해 설명한 given/when/then으로 파악</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">3. 주석의 설명이 실제 코드로는 정확한 표현 확인</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">꽤 복잡한 테스트를 진행할 때, 코드 사이사이 Assertion이 등장해서 위 패턴을 무너뜨리기도 한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">이럴 때는 아래와 같이 When과 Then을 교대로 정의할 수 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">또, 블록이 길어질 때 And 접속사를 사용하면 더 잘 읽힌다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657184314054" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void shouldTimeOutConnections() {
  // Given two users
  User user1 = newUser();
  User user2 = newUser();

  // And an empty connection pool with a 10-minute timeout
  Pool pool = newPool(Duration.minutes(10));

  // When connecting both users to the pool
  pool.connect(user1);
  pool.connect(user2);

  // Then the pool should have two connections
  assertThat(pool.getConnections()).hasSize(2);

  // When waiting for 20 minutes
  clock.advance(Duration.minutes(20));

  // Then the pool should have no connections
  assertThat(pool.getConnections()).isEmpty();

  // And each user should be disconnected
  assertThat(user1.isConnected()).isFalse();
  assertThat(user2.isConnected()).isFalse();
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">Name tests after the behavior being tested</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">테스트에서의 이름은 굉장히 중요하다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">테스트의 의도를 표현하는 방법이기도 하고,&nbsp;실패 시 테스트의 이름만 있다면 이름만으로 그 기능을 파악할 수 있어야 하기 때문이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">테스트의 이름은 검사하려는 행위를 요약해서 보여줘야 한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">시스템이 수행하는 동작과 예상 결과를 모두 담아야 좋은 이름이다.&nbsp;</span></p>
<p data-ke-size="size14"><span style="font-family: 'Noto Sans Light'; color: #000000;">관련 <a style="color: #000000;" href="https://testing.googleblog.com/2014/10/testing-on-toilet-writing-descriptive.html" target="_blank" rel="noopener">Tot 링크</a></span></p>
<p data-ke-size="size16">&nbsp;</p>
<blockquote data-ke-style="style2"><span style="font-family: 'Noto Sans Light'; color: #000000;">multiplyingTwoPositiveNumbersShouldReturnAPositiveNumber</span><br /><span style="font-family: 'Noto Sans Light'; color: #000000;">multiply_positiveAndNegative_returnsNegative</span><br /><span style="font-family: 'Noto Sans Light'; color: #000000;">divide_byZero_throwsException</span></blockquote>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">위와 같이 아주 복잡하고 긴 이름은 production code에서는 지양되지만, 테스트 코드에서는 괜찮다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">다양한 방식의 이름 짓기 전략을 사용해도 좋고, 좋은 전략이 없다면 'should'로 시작하는 이름을 사용해보아라.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<blockquote data-ke-style="style2"><span style="font-family: 'Noto Sans Light'; color: #000000;">shouldNotAllowWithdrawalsWhenBalanceIsEmpty</span><br /><span style="font-family: 'Noto Sans Light'; color: #000000;">-&gt; "BankAccount should not allow withdrawals when balance is empty."&nbsp;</span></blockquote>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Sans Light'; color: #000000;">Don&rsquo;t Put Logic in Tests</span></h3>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">논리는&nbsp;프로그래밍&nbsp;언어에서&nbsp;명령형&nbsp;요소&nbsp;(연산자,&nbsp;반복문,&nbsp;조건문&nbsp;등)를&nbsp;이용해&nbsp;표현합니다.&nbsp;논리가&nbsp;포함된&nbsp;코드의&nbsp;결과를&nbsp;예측하려면&nbsp;약간의&nbsp;정신노동을&nbsp;거쳐야&nbsp;합니다.&nbsp;코드를&nbsp;그냥&nbsp;훑는&nbsp;것만으로는&nbsp;부족하죠.&nbsp;더욱이&nbsp;테스트에서는&nbsp;논리가&nbsp;조금만&nbsp;들어가도&nbsp;추론하기가&nbsp;어려워집니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657185152876" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void shouldNavigateToAlbumsPage() {
  String baseUrl = "http://photos.google.com/";
  Navigator nav = new Navigator(baseUrl);
  nav.goToAlbumPage();
  assertThat(nav.getCurrentUrl()).isEqualTo(baseUrl + "/albums");
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">이 간단한 테스트에서 감춰진 버그가 보이나요?</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657185198421" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void shouldNavigateToPhotosPage() {
  Navigator nav = new Navigator("http://photos.google.com/");
  nav.goToPhotosPage();
  assertThat(nav.getCurrentUrl()))
      .isEqualTo("http://photos.google.com//albums"); // Oops!
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">전체 문자열을 바로 적으니, 버그가 바로 보인다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">중복된 코드가 있더라도, 서술적이고 의미 있는 테스트를 얻게된 가치가 있다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Sans Light'; color: #000000;">Write Clear Failure Messages</span></h3>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">실전에서는 테스트 실패 보고서나 로그에 찍힌 메시지 한 줄만으로 문제의 원인을 찾아내야 할 때가 많다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;"> 정작 그 메시지를 뿌린 테스트조차 주어지지 않은 채로 말이죠. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">잘 작성된 실패 메시지라면 테스트의 이름과 거의 동일한 정보를 담고 있어야 합니다. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">즉, &lsquo;원하는 결과&rsquo;, &lsquo;실제 결과&rsquo;, &lsquo;이때 건네진 매개변수의 값&rsquo;을 명확히 알려줘야 합니다</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657185333180" class="java" data-ke-language="java" data-ke-type="codeblock"><code>// bad
Test failed: account is closed

// better
Expected an account in state CLOSED, but got account:
    &lt;{name: "my-account", state: "OPEN"}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">좋은 실패 메시지는 기대한 상태와 실제 상태를 명확히 구분해주고, 결과가 만들어진 맥락 정보도 제공하는 것이 좋다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">구글이 개발한 Assertion 라이브러리인 <a style="color: #000000;" href="https://truth.dev" target="_blank" rel="noopener">Truth</a>를 Junit과 비교해보자.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657185564839" class="java" data-ke-language="java" data-ke-type="codeblock"><code>Set&lt;String&gt; colors = ImmutableSet.of("red", "green", "blue");

// JUnit: "expected &lt;true&gt; but was &lt;false&gt;"
assertTrue(colors.contains("orange"));

// Truth: "AssertionError: &lt;[red, green, blue]&gt; should have contained &lt;orange&gt;."
assertThat(colors).contains("orange");</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><span style="font-family: 'Noto Sans Light'; color: #000000;">Tests and Code Sharing: DAMP, Not DRY</span></h2>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">DAMP &mdash; "Descriptive And Meaningful Phrases."</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">DRY&nbsp; &nbsp; &mdash; "Don&rsquo;t Repeat Yourself"</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">테스트 코드는 보통 소프트웨어 코드와는 다르게 "반복하지 말라"라는 규칙의 DRY의 혜택이 그리 크지 않다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">오히려 "서술적이고 의미있는 구문"인 DAMP가 되도록 해야한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">DAMP는 DRY의 대체가 아니라 '보완'의 개념이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">검사 행위와 관련없는 반복코드를 추상화할 수 있는데, 여기서 핵심은 테스트의 리팩터링은 반복을 줄이는 게 아니라 더 서술적이고 의미있게 하는 방향으로 이뤄져야 한다는 것이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657186112412" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void shouldAllowMultipleUsers() {
  List&lt;User&gt; users = createUsers(false, false);
  Forum forum = createForumAndRegisterUsers(users);
  validateForumAndUsers(forum, users);
}

@Test
public void shouldNotAllowBannedUsers() {
  List&lt;User&gt; users = createUsers(true);
  Forum forum = createForumAndRegisterUsers(users);
  validateForumAndUsers(forum, users);
}

// Lots more tests...

private static List&lt;User&gt; createUsers(boolean... banned) {
  List&lt;User&gt; users = new ArrayList&lt;&gt;();
  for (boolean isBanned : banned) {
    users.add(newUser()
        .setState(isBanned ? State.BANNED : State.NORMAL)
        .build());
  }
  return users;
}

private static Forum createForumAndRegisterUsers(List&lt;User&gt; users) {
  Forum forum = new Forum();
  for (User user : users) {
    try {
      forum.register(user);
    } catch(BannedUserException ignored) {}
  }
  return forum;
}

private static void validateForumAndUsers(Forum forum, List&lt;User&gt; users) {
  assertThat(forum.isReachable()).isTrue();
  for (User user : users) {
    assertThat(forum.hasRegisteredUser(user))
        .isEqualTo(user.getState() == State.BANNED);
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657186128402" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Test
public void shouldAllowMultipleUsers() {
  User user1 = newUser().setState(State.NORMAL).build();
  User user2 = newUser().setState(State.NORMAL).build();

  Forum forum = new Forum();
  forum.register(user1);
  forum.register(user2);

  assertThat(forum.hasRegisteredUser(user1)).isTrue();
  assertThat(forum.hasRegisteredUser(user2)).isTrue();
}

@Test
public void shouldNotRegisterBannedUsers() {
  User user = newUser().setState(State.BANNED).build();

  Forum forum = new Forum();
  try {
    forum.register(user);
  } catch(BannedUserException ignored) {}

  assertThat(forum.hasRegisteredUser(user)).isFalse();
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">코드를 여러 테스트에서 공유하는 일반적인 패턴에는 아래와 같다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="font-family: 'Noto Sans Light'; color: #000000;">Shared Values</span></h4>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">각 테스트에서 사용되는 객체가 왜 그 값을 선택했는지 모호할 때가 있다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657186365225" class="java" data-ke-language="java" data-ke-type="codeblock"><code>private static final Account ACCOUNT_1 = Account.newBuilder()
    .setState(AccountState.OPEN).setBalance(50).build();
    
// Hundreds of lines of other tests...

@Test
public void canBuyItem_returnsFalseForClosedAccounts() {
  assertThat(store.canBuyItem(ITEM, ACCOUNT_1)).isFalse();
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">CLOSED_ACCOUNT&nbsp;나&nbsp;ACCOUNT_WITH_LOW_BALANCE 와 같은 이름을 줄 수는 있지만, 세부 정보를 알기는 어렵다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657186825029" class="java" data-ke-language="java" data-ke-type="codeblock"><code>// Languages like Java that don&rsquo;t support named parameters can emulate them
// by returning a mutable "builder" object that represents the value under
// construction.
private static Contact.Builder newContact() {
  return Contact.newBuilder()
    .setFirstName("Grace")
    .setLastName("Hopper")
    .setPhoneNumber("555-123-4567");
}

// Tests then call methods on the builder to overwrite only the parameters
// that they care about, then call build() to get a real value out of the
// builder.
@Test
public void fullNameShouldCombineFirstAndLastNames() {
  Contact contact = newContact()
      .setFirstName("Ada")
      .setLastName("Lovelace")
      .build();
  assertThat(contact.getFullName()).isEqualTo("Ada Lovelace");
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">자바에서는 위와 같이 Builder와 같이 정의해서 사용할 수 있다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="font-family: 'Noto Sans Light'; color: #000000;">Shared Setup</span></h4>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">셋업 객체는 하나의 test suite에 속한 테스트를 각각 수행하기 직전에 실행되는 메서드를 정의할 수 있게 해준다. 셋업 메서드는 대상 객체와 협력 객체 collavorator들을 생성하는 데 매우 유용하다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">어떤 인수를 넣는지 관심이 없고, 테스트 수행 후에도 객체 상태가 전혀 변하지 않는다면 매우 유용한 방법이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657187383157" class="java" data-ke-language="java" data-ke-type="codeblock"><code>private NameService nameService;
private UserStore userStore;

@Before
public void setUp() {
  nameService = new NameService();
  nameService.set("user1", "Donald Knuth");
  userStore = new UserStore(nameService);
}

// [... hundreds of lines of tests ...]

@Test
public void shouldReturnNameFromService() {
  UserDetails user = userStore.get("user1");
  assertThat(user.getName()).isEqualTo("Donald Knuth");
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">위에서 Donal Knuth 이름은 도대체 어디서 왔는지 찾기가 어려워진다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657187475393" class="java" data-ke-language="java" data-ke-type="codeblock"><code>private NameService nameService;
private UserStore userStore;

@Before
public void setUp() {
  nameService = new NameService();
  nameService.set("user1", "Donald Knuth");
  userStore = new UserStore(nameService);
}

@Test
public void shouldReturnNameFromService() {
  nameService.set("user1", "Margaret Hamilton");
  UserDetails user = userStore.get("user1");
  assertThat(user.getName()).isEqualTo("Margaret Hamilton");
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">위와 같이 setUp에서 설정한 userStore에서 이름을 가져와 비교할 수 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="font-family: 'Noto Sans Light'; color: #000000;">Shared Helpers and Validation</span></h4>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">하나의&nbsp;목적에&nbsp;집중하는&nbsp;검증&nbsp;메서드&nbsp;validation&nbsp;method&nbsp;는&nbsp;여전히&nbsp;유용합니다.&nbsp;잘&nbsp;만들어진&nbsp;검증용&nbsp;도우미&nbsp;메서드는&nbsp;여러&nbsp;조건을&nbsp;확인하는&nbsp;게&nbsp;아니라&nbsp;입력에&nbsp;대한&nbsp;단&nbsp;하나의&nbsp;&lsquo;개념적&nbsp;사실&rsquo;만을&nbsp;검증합니다.&nbsp;개념적으로는&nbsp;단순하지만&nbsp;그&nbsp;개념을&nbsp;검사하는&nbsp;로직이&nbsp;복잡한&nbsp;경우라면&nbsp;특히&nbsp;큰도움이&nbsp;됩니다.&nbsp;예를&nbsp;들어&nbsp;검증&nbsp;로직에&nbsp;반복문이나&nbsp;조건문이&nbsp;들어가서&nbsp;테스트&nbsp;메서드의&nbsp;명확성을&nbsp;떨어뜨리는&nbsp;경우라면&nbsp;검사&nbsp;로직이&nbsp;복잡하다고&nbsp;말할&nbsp;수&nbsp;있습니다.&nbsp;가령&nbsp;[코드&nbsp;12-25]의&nbsp;도우미&nbsp;메서드는&nbsp;계정&nbsp;접근&nbsp;권한과&nbsp;관련한&nbsp;여러&nbsp;테스트에서&nbsp;유용하게&nbsp;쓰일&nbsp;것입니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1657187634013" class="java" data-ke-language="java" data-ke-type="codeblock"><code>private void assertUserHasAccessToAccount(User user, Account account) {
  for (long userId : account.getUsersWithAccess()) {
    if (user.getId() == userId) {
      return;
    }
  }
  fail(user.getName() + " cannot access " + account.getName());
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">테스트 인프라 정의</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">하나의&nbsp;클래스나&nbsp;스위트에&nbsp;속한&nbsp;메서드들&nbsp;사이에서의&nbsp;코드&nbsp;공유에&nbsp;해당했습니다.&nbsp;그런데&nbsp;가끔은&nbsp;다른&nbsp;테스트&nbsp;스위트와도&nbsp;코드를&nbsp;공유하면&nbsp;유용할&nbsp;때가&nbsp;있습니&nbsp;다.&nbsp;구글은&nbsp;이런&nbsp;종류의&nbsp;코드를&nbsp;테스트&nbsp;인프라&nbsp;test&nbsp;infrastructure&nbsp;라고&nbsp;부릅니다.&nbsp;테스트&nbsp;인프라는&nbsp;주로&nbsp;통합&nbsp;테스트나&nbsp;종단간&nbsp;end-to-end&nbsp;테스트&nbsp;때&nbsp;빛을&nbsp;발합니다.&nbsp;그리고&nbsp;신중하게&nbsp;설계한다면&nbsp;특정&nbsp;상황에서는&nbsp;단위&nbsp;테스트를&nbsp;작성하는&nbsp;데도&nbsp;큰&nbsp;도움을&nbsp;줍니다</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">테스트&nbsp;인프라는&nbsp;많은&nbsp;곳에서&nbsp;호출되는&nbsp;만큼&nbsp;이에&nbsp;의존하는&nbsp;코드가&nbsp;많습니다.&nbsp;그래서&nbsp;동작이&nbsp;달라지면&nbsp;다른&nbsp;코드들이&nbsp;깨지기&nbsp;때문에&nbsp;변경하기도&nbsp;어렵습니다.&nbsp;달리&nbsp;말하면,&nbsp;일반적인&nbsp;테스트&nbsp;코드보다는&nbsp;제품&nbsp;코드와&nbsp;비슷한&nbsp;특성을&nbsp;보인다는&nbsp;뜻입니다.&nbsp;엔지니어들은&nbsp;각자&nbsp;맡은&nbsp;기능을&nbsp;테스트하면서&nbsp;공통&nbsp;테스트&nbsp;인프라까지&nbsp;변경할&nbsp;필요가&nbsp;없습니다.&nbsp;그래서&nbsp;테스트&nbsp;인프라는&nbsp;독립된&nbsp;제품&nbsp;대우를&nbsp;해줘야&nbsp;하며,&nbsp;마땅히&nbsp;자신을&nbsp;검사해줄&nbsp;&lsquo;자체&nbsp;테스트들을&nbsp;갖추고&nbsp;있어야&rsquo;&nbsp;합니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">핵심 정리&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 변하지 않는 테스트를 만들기 위해 노력하세요.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 공개 API를 통해 테스트하세요. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 상호작용이 아닌, 상태를 테스트하세요.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 테스트를 완전하고 명확하게 만드세요.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 메서드가 아닌, 행위를 테스트하세요.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 행위가 부각되게끔 테스트를 구성하세요.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 테스트 이름은 검사하는 행위가 잘 드러나게 지으세요.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 테스트에 로직을 넣지 마세요.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 실패 메시지를 명확하게 작성하세요.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Noto Sans Light'; color: #000000;">- 테스트들이 코드를 공유할 때는 DRY보다 DAMP를 우선하세요.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
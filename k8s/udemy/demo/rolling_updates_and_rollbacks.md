## Rolling Updates and Rollbacks


```Bash
# Create
❯ kubectl create -f deployment-definition.yml

# Get
❯ kubectl get deployments

# Update
❯ kubectl apply -f deployment-definition.yml

# Update
❯ kubectl set image deployment/myapp-deployment nginx=nginx:1.9.1

# Status
❯ kubectl rollout status deployment/myapp-deployment

# Status
❯ kubectl rollout history deployment/myapp-deployment

# Rollback
❯ kubectl rollout undo deployment/myapp-deployment
```


[//]: # (네 응용 프로그램을 업그레이드하는 방법을 알아보기 전에 배포 시 롤아웃과 버전 관리를 이해해보죠)

[//]: # (새로운 롤아웃은 새로운 배포 리비전즈를 생성합니다 리비전즈 원이라고 해보죠)

[//]: # (네 네 앞으로 앱이 업그레이드되면 컨테이너 버전이 새것으로 업데이트되면 새 롤아웃이 트리거되고)

[//]: # (새 배포 리뷰저가 생성됩니다 리비전즈 2라는 이름으로요)

[//]: # (네 배포에 일어난 변화를 추적할 수 있게 해주고 필요하다면 배포의 이전 버전으로 되돌릴 수 있게 해주죠)

[//]: # (네 이제 명령어 k벡틀:출시 상태를 실행해서 출시를 확인할 수 있습니다)

[//]: # (배포 이름과 함께요)

[//]: # (네 개정된 출격 기록과 역사를 확인하려면 큐벡틀 출격 기록 명령을 실행하고 배치)

[//]: # (이름을 입력하면 이 명령이 우리 배치 기록과 개정된 기록을 보여줄 겁니다 ⇲)

[//]: # (배포 전략에는 두 가지 유형이 있어요)

[//]: # (가령, 배포된 웹 응용 프로그램 인스턴스 복제본이 5개라고 치죠)

[//]: # (네 이걸 새로운 버전으로 업그레이드하는 한 가지 방법은 이것들을 모두 파괴하고 응용 프로그램 인스턴스의)

[//]: # (새로운 버전을 만드는 겁니다 실행 중인 5개의 인스턴스를 먼저 파괴한 다음 새 응용 프로그램 버전의)

[//]: # (새 인스턴스 5개를 배포한다는 뜻이죠)

[//]: # (네 이것의 문제는 예상하시겠지만 구 버전이 다운되고 새 버전이 업되기 전 기간)

[//]: # (동안 응용 프로그램은 다운되고 사용자에 접근이 불가능해요)

[//]: # (네 이 전략은 재생성 전략으로 알려져 있습니다 다행히 기본 배포 전략은 아니에요)

[//]: # (두 번째 전략은 한꺼번에 다 없애지 않는 거예요)

[//]: # (그 대신 구 버전을 내려서 하나씩 새 버전을 올리는 거죠)

[//]: # (이렇게 하면 앱이 다운되지 않고 업그레이드도 원활해지죠)

[//]: # (네 기억하세요 배포를 생성하는 동안 전략을 지정하지 않으면 롤 업데이트를 추정할 겁니다 )

[//]: # (롤 업데이트를 기본 배포 전략으로 사용한다는 거죠)

[//]: # (업그레이드 얘기를 했어요)

[//]: # (배치를 어떻게 업데이트하죠?)

[//]: # (업데이트요 업데이트라고 할 땐 다양한 걸 수도 있어요 응용 프로그램 버전을 업데이트하는 거죠)

[//]: # (사용된 docker 컨테이너 버전을 업데이트함으로써요)

[//]: # (라벨을 업데이트하거나 복제본 수를 업데이트하거나 기타 등등이요)

[//]: # (이미 배포 정의 파일이 있기 때문에 이 파일을 수정하기가 쉬워요)

[//]: # (필요한 수정을 하면 큐벡틀을 실행해 그 수정을 적용하는 명령을 적용해요)

[//]: # (새로운 출시 버전이 트리거되고 새로운 배포 리뷰가 생성되죠)

[//]: # (하지만 이 일을 할 다른 방법이 있어요)

[//]: # (네 kubectl 셋 이미지 명령을 이용해 응용 프로그램의 이미지를 업데이트할 수도 있습니다 하지만 기억하세요)

[//]: # (이런 식으로 하면 배포 정의 파일의 구성이 달라집니다 )

[//]: # (그러니 같은 정의 파일을 사용할 땐 조심해야 합니다 향후에 변경하려면요)

[//]: # (재생성과 롤링 업데이트 전략의 차이는 배포를 자세히 볼 때도 알 수 있죠)

[//]: # (네 k벡틀을 실행해 배포 명령을 설명하면 배포와 관련된 자세한 정보를 볼 수 있어요)

[//]: # (네 재생 전략을 언제 썼는지 알 수 있어요 이 자료에 따르면 원래 복제품은 처음엔 0으로 축소했다가 새 복제품은 5로 축소했어요)

[//]: # (그렇죠 하지만 롤링 업데이트 전략이 적용되면서 기존 복제품 세트를 하나씩 축소하고 새 복제품 세트도 동시에 축소했습니다 하나씩 말이죠)

[//]: # (배포가 업그레이드를 어떻게 수행하는지 살펴보죠 )

[//]: # (배포가 생성되면)

[//]: # (가령, 복제본 5개를 배포한다고 할 때 먼저 자동으로 복제본 세트를 생성합니다)

[//]: # (따라서 복제본 개수에 부합하는 포드 개수가 생성되죠)

[//]: # (네 응용 프로그램을 업그레이드할)

[//]: # (때 이전 슬라이드에서 봤듯이)

[//]: # (쿠버네테스 배포 개체가 후드 아래에 새 복제본 세트를 만들고)

[//]: # (컨테이너를 배포하기 시작해요 에어롤링을 따라 옛 복제본)

[//]: # (세트의 포드를 제거하는 동시에 ?)

[//]: # (네, 에어롤링이요 전략을 업데이트합니다)

[//]: # (네 이건 복제본 세트를 나열할 때 볼 수 있어요)

[//]: # (큐벡틀 복제본 가져오기 명령을 사용해서요 )

[//]: # (이건 발사대가 전혀 없는 예전 모형 세트이고 새 것은 5개만 있는 세트예요)

[//]: # (예를 들어 앱을 업그레이드하면 뭔가 잘못된 걸 알게 되죠)

[//]: # (업그레이드했던 새 버전에 문제가 있는 경우 업데이트를 롤백해야 합니다)

[//]: # (쿠버네티스 배포는 이전 리비전으로 롤백하게 해주죠)

[//]: # (변경된 것을 취소하려면 큐벡틀 롤아웃 취소 명령을 실행하고 배포 이름을 입력하세요)

[//]: # (새 복제품 세트의 배포는 새 복제품 세트의 포드를 파괴하고 옛날 복제품 세트의 예전 포드를 불러오죠 응용 프로그램은 옛날 형식으로 돌아가고요)

[//]: # (k벡틀 복제본 집합 명령 결과와 롤백 전과 후를 비교해보면 이 차이를 알 수 있어요)

[//]: # (롤백하기 전에 첫 번째 복제품 세트에는 포드 하나가 없었고 새 세트에는 다섯 개 있었어요 )

[//]: # (롤백이 끝난 후에는 이렇게 됐죠)


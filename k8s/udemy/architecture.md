## Architecture


쿠버네티스의 목적은 컨테이너 형태로 애플리케이션을 호스팅하여 여러 애플리케이션 인스턴스를 한번에 쉽게 배포하고, 애플리케이션 내의 서로 다른 서비스 간의 통신을 쉽게 가능하게 하는 것입니다.
쉬운 이해를 위해, 예시를 하나 들어보도록 하겠습니다.

두 개의 화물선이 있다고 가정해봅시다. 각 화물선에는 많은 컨테이너들을 싣고 있습니다.

컨테이너를 어느 화물선에 실을 지 뿐만 아니라, 방향을 조정하고, 모니터링하고 관리하는 화물 선이 필요합니다.

이 모든 것들을 다른 오피스와 부서로 운영하는 컨트롤 화물선에서 관리합니다. 이러한 관리 화물선은 쿠버네티스 클러스터의 master node와 관련이 있습니다. master node는 쿠버네티스 클러스터를 관리하는 역할입니다. 서로 다른 노드에 대한 정보를 저장하거나, 컨테이너를 배치 시키고, 노드와 컨테이너들을 모니터링합니다.

수 많은 컨테이너들이 운행될 경우, 몇개의 화물선에 얼마나 많은 컨테이너가 있는지에 대한 정보가 필요한데요. 이 모든 정보는 ETCD 라는 높은 가용성의 key-value 스토리지에 저장됩니다.

Etcd에서는 어떤 데이터가 어떠한 방식으로 저장되는지 알아볼 필요가 있습니다.

컨트롤 화물선에 있는 컨테이너들을 화물선에 할달할 때, 이 때 크레인을 사용한다고 해봅시다. 이 크레인은 특정 컨테이너가 어떤 화물선에 배치되어야 하는지를 식별할 수 있습니다. 가령, 수용량이나 특정 화물선에 이미 선박된 컨테이너가 몇 개 있는지, 혹은 화물선의 목적지, 운반 가능한 타입인지 등의 조건들을 이미 알고 있는 것이죠.

바로 이 크레인이 kube-scheduler 의 역할입니다. 쿠버네티스 스케쥴러가 하는 일들은 중요하기 때문에 한 번 깊이 파는 시간을 가져볼 필요가 있습니다.

이 컨트롤 화물선에는 또한, 특정 영역에 특화된 부서들이 있습니다. 가령 운영팀은 화물을 조정하거나 트래픽을 통제하는 등의 일들을 합니다. 이슈를 처리하거나 경로에 맞는 화물선으로 경로를 조정하는 등의 일들을 처리하곤 합니다. 쿠버네티스에서도 비슷하게 서로 다른 영역 들에 특화된 컨트롤러들이 존재합니다. Node Controller는 노드를 관리합니다. Replication Controller들은 레플리케이션 그룹에 동시에 할당되어야 하는 개수(desired number)에 맞춰 새로운 노드들을 클러스터에 할당하거나 제거합니다.

그런데, 이렇게 컨테이너들을 관리하는 각각의 역할을 가진 부서들은 어떻게 서로에게 정보나 상태를 전달할까요? Kube API 서버가 바로 이 커뮤니케이션의 중추가 됩니다. 클러스터 내 모든 오퍼레이더들을 오케스트레이팅해줍니다. Kube API 서버는 외부 사용자들에게 Kubernetes API를 노출시키는데, 이를 통해 클러스터의 상태를 모니터링하기 위한 다양한 컨트롤러들이나 요구되는 필요한 변경 사항을 반영하거나, 워커 노드들이 서버와 커뮤니케이션할 수 있게 하여 클러스터의 운영을 관리합니다.

이렇게 쿠버네티스 세상에는 모든 것들이 컨테이너로 동작하는데요. 그래서 모든 환경 또한 컨테이너 환경에 맞게 동작되게 됩니다.

전 시스템을 관리하기 위한 형식의 서로 다른 컴포넌트들은 컨테이너의 형식으로 호스팅될 수 있습니다. 또, DNS 서비스 또한 컨테이너의 형식으로 배포됩니다.

그래서 우리는 이 모든 컨테이너들을 실행시킬 소프트웨어가 필요한데, 이것이 바로 컨테이너 런타임 엔진입니다. 가령, 유명한 것으론 Docker가 있죠. 그래서 쿠버네티스 클러스터들의 마스터 노드 (만약 컨테이너로 실행시키길 원한다면)를 포함해서, 모든 노드들이 컨테이너 실행시키도록 하기 위해 Docker가 필요한 것입니다. 쿠버네티스는 Docker 뿐만아니라 다른 Runtime Engine으로 Container 나 Rocket 등을 지원합니다.

이 번엔 화물선에 조금 더 집중해보도록 하겠습니다. 모든 화물선에는 선장이 있습니다. 선장은 이 화물선의 모든 이벤트들을 관리합니다. 이 선장은 중요 임무는 모선(컨트롤 화물선, mastership)과 통신하며 모선에게 그룹에 합류할 의사나, 해당 화물선에 적재되는 컨테이너들에 대한 정보를 받는다거나, 적절한 컨테이들이 필요 시 적재할 수 있는지를 알려주고 해당 화물선이나 컨테이너 들에 대한 상태에 대한 보고를 마스터로 부터 받습니다.

쿠버네티스의 kubelet이 바로 쿠버네티스 내의 선장의 역할입니다. kubelet은 클러스터 위의 각 노드에서 실행되는 Agent입니다.

Kube API 서버로부터 오는 지시 사항을 듣고, 필요할 때 컨테이너를 배포하거나 제거합니다. Kube API 서버는 주기적으로 노드의 상태나 해당 노드의 컨테이너의 상태를 모니터하기 위해 kubelet으로 부터 상태값을 가져옵니다.

kubelet은 화물선의 컨테이너를 관리하는 배의 선장에 가까웠는데요.

하지만, Worker node에서 실행되고 있는 애플리케이션은 종종 다른 Worker Node와 통신하고 싶어질 수 있습니다. 가령, 웹 서버가 한 컨테이너에서 실행될 때 다른 워커 노드에서 실행 중인 데이터베이스와 연결하고 싶을 때가 있죠. Kube Proxy Service는 작업자 노드에서 실행 중인 컨테이너가 서로 도달할 수 있도록 작업자 노드에 필요한 규칙이 있는지 확인합니다

요약하자면, 마스터 노드와 워커 노드가 있습니다.
마스터에는 클러스터에 대한 정보를 저장하는 etcd 클러스터가 있습니다.
노드에서 애플리케이션이나 컨테이너 예약을 담당하는 큐브 스케줄러가 있습니다.
노드 컨트롤러, 복제 컨트롤러 등 다양한 기능을 처리하는 다양한 컨트롤러가 있습니다.
클러스터 내의 모든 작업을 조정하는 역할을 하는 Kube API 서버가 있습니다.
작업자 노드에는 Kube API 서버의 명령을 듣고 컨테이너를 관리하는 Kubelet과 클러스터 내의 서비스 간 통신을 가능하게 하는 Kube Proxy가 있습니다.

따라서 다양한 구성 요소에 대한 높은 수준의 개요입니다.
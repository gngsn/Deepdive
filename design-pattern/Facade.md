## Facade Pattern

<small>*p. 244*</small>

<small>| **한 줄 소개** | 복잡한 객체의 구조와 접근을 간단하게 표현하는 방법 </small>

<br/>

관심사를 분리하는 패턴. 객체지향은 추상적인 개념을 도입해 객체를 캡슐화. 캡슐화를 적용했다고 해서 객체 내 서브 시스템으로 접근할 수 없는 것은 아니며, 이런 점에서 은닉성은 떨어지는 편

퍼사드facade의 어원은 프랑스어로 건물의 정면이라는 뜻을 가짐, 건물의 외관, 겉모습을 말하며 사전적으로는 ‘표면, 허울’로도 해석

<br/>

## 11.1 협업을 위한 분리 작업

협업과 대형 시스템을 개발하고 배포하는 데 자주 응용되는 패턴. 시스템 결합과 사용이 용이하도록 관심사를 분리

<br/>

### 11.1.1 복잡한 구조의 개발 작업

개형 시스템을 효율적으로 개발하려면 기능을 모듈별로 분리하고 분리된 모듈을 공동으로 개발하는 것이 좋음

오픈소스나 공개된 API 서비스를 이용하는 것도 좋은 방안

<br/>

### 11.1.2 분리된 모듈의 결합

하나의 서비스를 여러명의 개발자와 공동으로 만드는 과정은 쉽지 않으며, 분리된 기능별 모듈을 하나로 합치는 과정에서 수많은 난관에 봉착함

모듈은 다른 모듈을 참조하기 때문에, 모듈을 결합하기 위해 타인의 개발 코드를 이해하는 과정이 필요한데 각 클래스의 실행 순서와 조작 방법이 다를 수도 있음

<br/>

### 11.1.3 느슨한 결합

코드는 분할된 모듈을 결합할 때 강력한 의존 관계를 갖음. 퍼사드 패턴은 강력한 결합 구조를 해결하기 위해 코드의 의존성을 줄이고 느슨한 결합으로 변경

퍼사드 패턴은 메인 시스템과 서브 시스템 중간에 위치하는데, 새로운 인터페이스 계층을 추가하여 시스템 간 의존성을 해결

퍼사드로 인해 새로운 계층이 하나 더 추가되면 관리할 클래스가 하나 더 생성된다는 단점이 있지만, 강력한 객체의 결합도를 낮추고 유연한 구조를 가질 수 있다는 장점이 있음

<br/>

### 11.1.4 간접 접근

처사드를 이용하면 객체(서브 세스템)의 내부 구조를 상세히 알 필요가 없음 처사드는 시스템의 연결성과 종속성을 최소화하는 것을 목적으로 함

외부 라이브러리를 가져와 함수를 사용하는 것도 퍼사드 역할.

<br/>

## 11.2 facade 패턴을 응용한 API

클라우드, 서비스 API를 구축할 때 응용되는 패턴

<br/>

### 11.2.1 구조

싱글턴 추상 팩토리 singletone abstract factory 라고 불리기도 함. 어떤 기능에 접근할 수 있는 단일화된 추상 클래스를 만듦

은행에 갈 때 은해 내부 시스템을 몰라도 은행 업무를 처리할 수 있고, 은행원은 고객과 은행 전산 시스템을 이어주는 인터페이스 역할

처사드는 단순한 창구 역할의 은행원과 같음

<br/>

### 11.2.2 인터페이스

퍼사드를 이용하면 코드를 사용하는 클라이언트 측에서 세부적인 기능을 일일이 알 필요가 없음

퍼사드로 제공되는 클래스, 함수를 이용하기만 하면 됨. 이처럼 간단한 사용법을 제공하는 것이 바로 퍼사드 패턴

<br/>

### 11.2.3 최상의 인터페이스

퍼사드는 서브 시스템을 보다 쉽게 쓸 수 있도록 높은 수준의 인터페이스를 정의하는 작업

<br/>

## 11.3 facade를 이용한 단순화

facade는 복잡한 서브 시스템의 동작을 하나로 붂어서 이를 실행할 수 있도록 제공하는 계층

<br/>

### 11.3.1 단순화

<br/>

### 11.3.2 캡슐화 배제

퍼사드 패턴을 구현하기 위해 서브 시스템의 캡슐화 작업을 별도로 진행하지는 않음. 단순한 인터페이스일 뿐임

<br/>

### 11.3.3 복잡성 해결

서브 시스템을 구조화하여 복잡성을 해결하는 데 도움을 줌

퍼사드는 인터페이스를 이용하여 실제 구현부를 분리하므로 서브 시스템을 계층화하여 처리할 때 매우 유용

<br/>

### 11.3.4 의존성 감소

<br/>

## 11.4 최소 지식 원칙

최소 지식 원칙 principle of Least Knowledge = 데메테르의 법칙 Law of Demeter

<br/>

### 11.4.1 최소 지식

지식으로 장벽을 만들지 않아야 함. 최소 지식만 적용해 객체의 상호 작용을 설정하면 유지 보수가 용이해짐

복잡하게 얽혀 있는 서브 시스템의 어떤 부분을 수정할 경우 관련된 다른 부분도 같이 수정해야하는 경우가 있어서, 하나를 수정할 때 많은 연관 정보를 알고 있어야 한다. 때문에, 파사드 패턴은 객체지향의 최소 지식 원칙이 적용되는 좋은 예

<br/>

### 11.4.2 잘못된 예

<br/>

### 11.4.3 최소 지식 객체

최소 지식 원칙을 적용하여 코드를 작성하는 것이 오히려 더 복잡해 보일 수 있음. 하지만 다음의 4가지 규칙만 따르면 최소 지식 원칙을 쉽게 적용할 수 있음

<br/>

- 자기 자신만의 객체 사용
- 메서드에 전달된 매개변수 사용
- 메서드에서 생성된 객체 사용
- 객체에 속하는 메서드 사용

<br/>

```java
class Car {

	// ① 클래스의 구성 요소
	// 구성 요소의 메서드는 호출해도 된다.
	private Engine engine;

	public Car(String engine) {
		this.engine = engine;
	}

	public void start(Key key) {
		// ③ 새로운 객체 생성
		// 내부에서 생성된 객체의 메서드는 호출해도 됨
		doors = new Doors();

		// ② 매개변수로 전달된 객체의 메서드는 호출해도 됨
		authorized = key.turns();

		if (authorized) {
			// ① 객체의 구성 요소의 메서드는 호출해도 됨
			engine.start();

			// ④ 객체 내에 있는 메서드는 호출해도 됨
			this.updateDashboardDisplay();

			// ③ 직접 생성하거나 인스턴스를 만든 객체의 메서드는 호출해도 됨
			doors.lock();
		}
	}

	public void updateDashboardDisplay() {
		// 생략
	}
}
```

facade 패턴을 적용할 때는 최소 단위의 원칙을 적용하여 클래스를 설계하는 것이 좋음

<br/>

## 11.5 기본 실습

<br/>

### 11.5.1 서브 시스템

- Package
    
    ```java
    package facade;
    
    public class Package1 {
        public Package1() {
            System.out.println("Package1 객체가 생성되었습니다.");
        }
    
        public void process() {
            System.out.println("Package1 작업을 진행합니다.");
        }
    }
    ```
    
    ```java
    package facade;
    
    public class Package2 {
        public Package2() {
            System.out.println("Package2 객체가 생성되었습니다.");
        }
    
        public void process() {
            System.out.println("Package2 작업을 진행합니다.");
        }
    }
    ```
    
    ```java
    package facade;
    
    public class Package3 {
        public Package3() {
            System.out.println("Package3 객체가 생성되었습니다.");
        }
    
        public void process() {
            System.out.println("Package3 작업을 진행합니다.");
        }
    }
    ```
    
<br/>

### 11.5.2 직접 접근

- Main
    
    ```java
    package facade;
    
    public class Main {
        public static void main(String[] args) {
            Package1 obj1 = new Package1();
            obj1.process();
    
            Package2 obj2 = new Package2();
            obj2.process();
    
            Package3 obj3 = new Package3();
            obj3.process();
        }
    }
    ```
    
<br/>

### 11.5.3 파사드 생성

- Facade
    
    ```java
    package facade;
    
    public class Facade {
        private Package1 package1;
        private Package2 package2;
        private Package3 package3;
    
        public Facade() {
            this.package1 = new Package1();
            this.package2 = new Package2();
            this.package3 = new Package3();
        }
    
        public void processAll() {
            this.package1.process();
            this.package2.process();
            this.package3.process();
        }
    }
    ```
    
- 수정된 Main
    
    ```java
    package facade;
    
    public class Main {
        public static void main(String[] args) {
            /* facade 적용 전
    
            Package1 obj1 = new Package1();
            obj1.process();
    
            Package2 obj2 = new Package2();
            obj2.process();
    
            Package3 obj3 = new Package3();
            obj3.process();
            */
    
            // facade 적용 후
            Facade facade = new Facade();
            facade.processAll();
        }
    }
    ```

<br/>    

## 11.6 파사드 패턴의 효과

시스템을 구조화하면서 복잡성을 해결하는데 도움이 됨

<br/>

### 11.6.1. 서브 시스템 보호

서브 시스템의 구성 요소를 직접 호출하지 않으므로 잘못된 사용을 방지할 수 있음

내부 구조와 외부 사용을 구분 → 서브 시스템을 업그레이드하는 경우에도 자유로움

<br/>

### 11.6.2 확장성

서비스를 유지하는 동안 새로운 요청과 생각하지 못했던 오류가 발견되곤 하므로, 안정적인 서비스를 유지하기 위해서는 지속적인 코드 변경이 필요

시스템은 새로운 기능을 구현하기 위해 확장되며, 최적화 및 재사용을 위해 기존의 클래스가 단순해지기를 바람

이 때 변화되는 코드를 파사드 형태로 제공하면 보다 쉽게 변경 및 확장할 수 있고, 상위 시스템에는 파사드를 이용하므로 서브 시스템이 변경돼도 큰 변화를 느낄 수 없음

서브 시스템의 기능을 유지할 수 있도록 완충하는 역할을 수행

<br/>

### 11.6.3 결합도 감소

서브시스템과의 종속성이 강할 때 퍼사드 패턴을 사용 → 결합도를 낮출 수 있음

<br/>

### 11.6.4 계층화

<br/>

### 11.6.5 이식성

코드의 결합도를 약하게 하는 효과를 발생시킴

코드 결합도가 약해지면 다른 응용 프로그램에서도 코드를 쉽게 재사용할 수 있음

다양한 응용 프로그램에서 서브 시스템을 공통적으로 사용할 수 있도록 이식성을 향상시킴

여러 작업을 하나의 묶음으로 처리하며 복잡한 클래스를 단순화함

<br/>

### 11.6.6 공개 인터페이스

파사드를 사용하면 필요한 행위만 노출하고 그 외의 코드를 비공개로 숨길 수 있음

외부에 공개되는 기능과 공개되지 않는 기능을 구분할 수 있음

인터페이스를 제공함과 동시에 서브 시스템의 기능을 캡슐화함. 인터페이스를 활용한 캡슐화를 통해 공개할 부분과 공개하지 않을 부분을 결정함

<br/>

## 11.7 관련 패턴

|  | 추상 팩토리 패턴 | 어댑터 패턴 | 중재자 | 싱글턴 |
| --- | --- | --- | --- | --- |
| 유사성 | 서브 시스템을 독립적으로 처리하기 위해 인터페이스를 제공. 이때 인터페이스를 facade 패턴과 같이 적용하여 설계할 수도 있음. 추상 팩토리도 종속적인 서브 클래스를 감추는 효과를 가짐 | 인터페이스를 제공한다는 측면에서 유사.  | 복잡한 접근과 동작을 총제한다는 측면에서 중재자 패턴과 유사.  | 파사드 패턴에서 서브 시스템의 접근을 단일화하기 위해 싱글턴 패턴을 응용. 싱글턴을 통해 파사드 객체를 생성하는 방식을 적용하는 경우도 많음 |
| 차별성 |  | 사용 용도가 다름. 어댑터는 단순히 차이점을 해결하기 위한 인터페이스라면, 파사드는 쉬운 접근과 동작을 위한 인터페이스를 제공. | 파사드는 가시적이고 직접적으로 접근하는 반면, 중재자는 은밀하고 비강제적으로 접근. 중재자 패턴은 클래스 접근을 중계하는 기능을 수행하며 양방향성이지만, 파사드는 단방향이며 서브 시스템의 접근만 허용 |  |

<br/>

## 11.8 정리

간단하며 일상적으로 많이 사용되는 패턴. 사실 수많은 API 서비스와 라이브러리, 패키지를 사용하면서도 이들이 파사드 패턴을 응용하고 있다는 것을 모르는 경우가 많음
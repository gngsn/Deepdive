## Strategy Pattern

<small>*p. 497*</small>

<small>| **한 줄 소개** | 객체의 행위를 추상화를 통해 공통된 단계와 공통되지 않은 단계를 분리함으로써 다양한 로직을 독립적인 알고리즘 객체로 분리하여 처리.    </small>

<br/>

전략 패턴은 객체 내부에서 해결해야 하는 목적을 알고리즘 객체로 분리 적용하는 기법.

실제 내부 동작을 외부 알고리즘 객체로 분리하여 유연하게 동작을 변경시킬 수 있음

<br/>

## 23.1 문제

<br/>

### 23.1.1 전략

전략은 어떤 목표를 정하고 진행하는 큰 틍릉 말하며, 군대에서 적과 싸울 때의 작전에 비유할 수 있음.

즉 전략은 앞으로 무엇을 할지 계획하는 것이며 ‘What to’를 의미함. 이처럼 프로그램에서 전략은 실행하는 큰 틀을 의미

한 번 계획한 전략을 수정하는 일은 쉽지 않고 개발이 진행되고 있거나 완료된 프로그램에서 전략을 수정하면 많은 시간과 비용이 소모됨.

또한 잘못된 전략은 프로그램에 치명적인 결과를 가져옴. 전략은 향후 프로젝트를 완성 및 성공시키는 데 매우 중요함

<br/>

### 23.1.2 전술

전술은 전략을 짜면서 정한 목표를 달성하기 위한 상세 내용이며 ‘How To’를 의미함

또한 전술은 방법론을 의미하며 전략은 방법을 구하는 것을 말함

전술은 전략을 수행하기 위한 효과적인 행동을 말하는데, 전략 패턴에서 전략은 알고리즘이고 전술은 실제 알고리즘이 동작하는 상세 내용

<br/>

## 23.2 알고리즘

<br/>

### 23.2.1 해결 방법의 변화

한 번 개발된 프로그램은 산업 현장에서 생각보다 오랫동안 사용되고, 이러한 프로그램은 시간이 지나면서 환경적인 영향을 받으므로 변화가 필요함

프로그램의 버그 또한 환경 변화에 의해 발생되며 이 경우 코드 수정이 필요

간 단한 변화는 코드 몇 줄만 수정해도 해결할 수 있지만, 잦은 코드 수정으로 변경 사항이 누적되면 더 이상 수정이 어려워짐

외부적으로 큰 환경 변화가 있을 때는 코드 수정이 어려움

큰 변화가 요구되면 기존의 방법을 버리고 새로운 방법을 도입하는 것이 현명하며 이때 리팩터링이 필요함

<br/>

### 23.2.2 다양성

프로그램의 목표는 주어진 문제를 해결하는 것.

문제를 해결하는 방법은 다양하며 한 가지 문제를 해결하는 방법은 수십, 수백 가지가 존재. 또한 발생한 문제는 다르지만 유사한 방법으로 해결할 수도 있음

문제를 해결하는 방법을 다르게 적용하려고 함. 해결 방법이 변경되면 관련 코드도 같이 수정해야 하는데, 이때 코드를 찾고 오래된 코드를 다시 분석하는 등 많은 시간이 필요

<br/>

### 23.2.3 분리

프로그램이 외부 변화에 보다 쉽게 적응하려면 변화가 예상되는 부분을 분리하는 것이 좋음. 코드를 분리해서 관리하면 유지 보수 측면에서 유리함

변화가 예상되는 부분을 별도의 클래스로 분리하고 대부분 처리 로직 부분의 변화가 예상되며, 이처럼 분리된 처리로직을 알고리즘이라고 함 알고리즘은 문제를 해결하는 하나의 패턴

<br/>

### 23.2.4 알고리즘

알고리즘은 복잡한 문제를 어떤 방법으로 실행했을 때 문제가 해결되는 방법. 알고리즘을 적용하여 문제를 쉽게 해결할 수 있음. 알고리즘은 문제 해결을 위한 동작을 다양하게 갖고 있는데, 이 동작은 추상화하여 처리함. 사용자는 알고리즘의 내부 실행 동작을 이해할 필요가 없으며, 알고리즘을 사용할 수 있는 인터페이스만 확인하고 절차에 따라 호출해서 사용하면 됨

<br/>

## 23.3 분리

<br/>

### 23.3.1 템플릿 메서드

<br/>

### 23.3.2 캡슐화

<br/>

### 23.3.3 구조 유지

내부적인 구조를 유지하기 위해서는 인터페이스를 적용해 설계해야 함

23.4 인터페이스

23.4.1 호환성

전략 패턴은 변화되는 부분을 찾아 알고리즘으로 분리함

구조의 일부분을 알고리즘으로 분리할 때는 구조적 호환성을 유지하는 것이 중요

```java
public interface Weapon {
    void attack();
}
```

<br/>

### 23.4.2 구체화

전략패턴은 공통된 부분과 변화되는 부분을 분리함

전략패턴에서 사용되는 알고리즘 클래스는 인터페이스를 적용하여 구체화

```java
public class Knife implements Weapon {
	public void attack() {
		System.out.println("칼 공격");
	}
}
```

```java
public class Gun implements Weapon {
	public void attack() {
		System.out.println("총 발포");
	}
}
```

<br/>

### 23.4.3 다형성

인터페이스 - 구조적 관계를 유지한다는 약속

<br/>

## 23.5 전략

Strategy는 영어로 전략이라는 의미이며, 전략 패턴은 정책policy 패턴이라고도 부름

<br/>

### 23.5.1 개발 부채

23.5.2 전략의 필요성

객체의 행위는 메서드로 구현하고, 구현된 메서드는 일반적으로 객체 내부에 위치함

하지만 전략 패턴은 객체의 행위를 메서드로 구현하지 않고 별도의 객체로 분리함

<br/>

### 23.5.3 복합 구조와 의존성

전략 패턴은 대표적인 복합 구조 형태의 객체 객체를 상속하는 대신 의존성으로 객체의 관계를 설정

의존된 외부의 객체는 객체 구조를 확장할 수 있음

처리할 알고리즘을 위임하는 형태로 객체에 실제 동작 처리를 요청

위이믕로 결합된 알고리즘 객체는 다른 알고리즘 객체로 쉽게 변경할 수 있음

알고리즘 하나가 모듈 형태로 위임되어 의존성 결합이 이뤄짐

<br/>

### 23.5.4 추상화

Strategy 클래스는 추상 클래스고, 전략 패턴에서 사용하는 인터페이스는 전략을 적용하기 위한 추상 메서드

```java
public abstract class Strategy {
    protected Weapon delegate;

    public void setWeapon(Weapon weapon) {
        System.out.println("-- 무기 교환 --");
        this.delegate = weapon;
    }

    public abstract void attack();
}
```

<br/>

### 23.5.5 구체적인 전략

전략 패턴의 실제적인 하위 클래스를 구현

전략 패턴은 **특정 알고리즘에 종속되어 동작하지 않으며, 언제든지 알고리즘을 변경해서 적용할 수 있음**

```java
public class Charactor extends Strategy{
    @Override
    public void attack() {
        if (this.delegate == null) {
            // 무기 선택 안한 경우
            System.out.println("맨손 공격");
        } else {
            this.delegate.attack();
        }
    }
}
```

<br/>

### 23.5.6 실시간 교체

전략 패턴은 알고리즘을 상호 교환할 수 있게 함

패턴화로 분리된 알고리즘 객체는 전략 객체의 외부로부터 전달받아 관계를 설정(의존성 주입)

<br/>

### 23.5.6 접근점

<br/>

## 23.6 전략 실행

전략 패턴은 객체 간 책임을 분할하고 협력하며 효율적으로 협업하기 위해 알고리즘을 적용함

<br/>

### 23.6.1 사령관

<br/>

### 23.6.2 실행

```java
public class Main {
    public static void main(String[] args) {
        Charactor obj = new Charactor();
        obj.attack();

        obj.setWeapon(new Knife());
        obj.attack();

        obj.setWeapon(new Gun());
        obj.attack();
    }
}
```

<br/>

### 23.6.3 행동 통합과 객체

전략 패턴에서는 행동을 여러 개의 알고리즘으로 분리하며 복수의 행동을 하나의 객체로 통합해 결합함

복수의 행동을 조건문으로 처리하는 것보다 단일 알고리즘으로 객체를 분리하는 것이 좋음. 선택한 알고리즘 객체만 실행해 전술을 실행함

<br/>

### 23.6.4 동적 처리와 매개변수

<br/>

### 23.6.5 실행 중 교체

전략을 위한 알고리즘은 다양하며 알고리즘을 교체하거나 결합하려면 일정한 규격이 필요함

또한 전략 패턴을 공통적으로 적용하려면 인터페이스를 설계하고, 인터페이스에 의해 알고리즘을 캡슐화함

전략패턴으로 알고리즘을 분리하여 구현하는 것은 동적으로 알고리즘을 교체하기 위함

인터페이스로 정의된 기능을 호출할 때 서로 교환하여 복수의 기능을 호출해 처리

전략 패턴은 위임을 구현하기 위해 추상적인 접든점을 생성함 

추상적인 접근은 위임된 객체를 가리키는 연결고리

위임되는 객체의 정보는 매개변수로 전달함

관계를 가진 내부 프로퍼티를 참조하여 객체를 서로 교환하고, 의임을 통해 내부 처리를 변화시킴

<br/>

## 23.7 적용 사례

전략 패턴은 실제 프로젝트에서 가장 많이 사용되는 패턴 유형 중 하나

<br/>

### 23.7.1 정렬 적용 사례

대표적으로 버블 정렬, 셸 정렬, 퀵 정렬 등 다양한 알고리즘을 갖음

즉, 전략 패턴을 알고리즘을 변경하여 문제를 해결하는 데 매우 유용

<br/>

### 23.7.2 통신 적용 사례

통신 프로토콜을 변경하는 시스템에도 적용할 수 있음

모바일 접속 시 LTE 프로토콜을 사용할지, Wifi 프로토콜을 사용할지 등의 알고리즘을 전략 패턴으로 구현할 수 있음

<br/>

## 23.8 관련 패턴

23.8.1 플라이웨이트 패턴

전략 패턴으로 분리된 알고리즘 객체를 공유하여 사용하는 경우도 있음. 알고리즘을 공유할 때는 플라이웨이트 패턴을 응용

<br/>

### 23.8.2 추상 팩토리 패턴

전략 패턴은 알고리즘은 교체하여 사용

객체를 교체한다는 픅면에서 추상 팩토리 패턴과 유사점이 있음. 추상 팩토리는 공장, 부품, 제품 등 객체를 교체할 수 있기 때문

<br/>


전략 패턴은 알고리즘을 위임으로 사용. 위임을 적극적으로 적용하여 관계를 형성하는 것이 상태 패턴과 많이 유사

행동 패턴에 유사한 점은 있지만 처리하려는 목적이 서로 다음. 전략 패턴의 경우 변경여부는 정할 수 있지만 필요에 의해 알고리즘을 변경하는데, 상태 패턴에서는 상태가 변할 때 위임 객체도 변경됨

<br/>

## 23.9 정리

전략 패턴을 이용하면 원라는 알고리즘을 선택적으로 교환할 수 있음. 또한 다양한 알고리즘을 응용하려면 기능을 차악하고 문제를 해결할 수 있도록 학습이 필요함

전략 패턴은 알고리즘의 객체를 교환하여 사용한다는 측면에서 유용한 패턴. 교환되는 처리 로직을 알고리즘화하여 객체의 군을 형성할 수도 있음. 전략 채턴은 행동 변경 시 조건문을 사용하지 않음 알고리즘 캡슐화를 통해 조건문 없이도 원하는 행동으로 교체할 수 있음

하지만 알고리즘 객체가 교체된다는 점에서 실행 시 많은 수의 객체를 갖는다는 단점도 있음
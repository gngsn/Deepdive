# Decorator Pattern

<br/>

> Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.
> 

<br/>

개체에 동적으로 추가 책임을 부여. 데코레이터는 기능 확장을 위한 subclass에 대한 유연한 대안을 제공.

<br/>

**기능 추가**

새로운 기능을 추가하기 위해 클래스를 확장하는 방법은 **상속**과 **구성** 두 가지임

<br/><br/>

### 상속

프로그램이 실행되면서 기존 객체를 확장해 새로운 기능을 추가해야 하는 경우가 있다. 객체지향에서는 새로운 기능을 추가하기 위해 상속을 사용.

하지만 상속의 단점은 상위 클래스와 하위 클래스 간에 강력한 결합 관계가 생성된다는 것.

상속은 정적 방식으로 기능을 확장하기 때문에, 객체를 상황에 맞게 동적으로 확장해야 할 경우 상속으로 구현하는 것이 쉽지 않음.

<br/>

**상속 조합**

상속을 이용해 객체를 유연하게 확장하는 것은 쉽지 않음. 어떤 행위는 필요하고 어떤 행위는 불필요할 때 객체의 조합을 다양하게 처리하는 일이 복잡해짐

원하는 기능만 상속해서 조합된 클래스를 생성해야함. 상속으로만 조건을 조합해 특정 행위만으로 구성된 객체를 생성하는 것은 매우 복잡함. 기능 별로 조합하고 하위 클래스도 개별적으로 생성해야 합니다.

<br/><br/>

### 조건 추가

하나의 간일 행위만 처리하는 것과 달리 여러 행위를 처리해야 하는 경우가 있다. 이 때 여러 행위를 구분하기 위해서 다른 행위를 하기 위해 기존을 행위를 확장하는 것과 같은 조건을 추가한다.

<br/>

**동적 확장을 위한 구성**

최근 모던 객체 지향 코드는 고전적인 상속보다 구성을 이용해 객체를 확장하는데, 이 경우 객체를 싱행하는 도중엑도 동적으로 다른 객체를 결합해 확장 가능하다는 장점이 있다.

장식자 패턴은 동적으로 객체를 결합하기 위해 객체지향의 구성을 통해 확장함

<br/><br/>

### 확장

장식자 패턴은 객체에 새로운 부가 기능을 동적으로 추가함. 여기서 동적은 실시간으로 변하는 객체에 새로운 행위를 투가하는 것을 의미

<br/>

**처리 분담**

책임이 향후에 어떤 형태로 변경될지 모르니 하나의 클래스에 많은 기능을 집중하는 것은 좋지 않으며 객체의 책임을 여러 클래스에 분산해 설계하는 것이 좋다. 보다 작은 객체가 재사용하기 용이하므로 칠요한 기능만 선택적으로 결합함. 

분산된 각각의 클래스는 작은 객체로 생성되며 더 큰 객체로 결합해 사용할 수 있고, 필요할 때마다 분산된 작은 객체를 결합해 새로운 객체로 생성할 수 있음, 또한 객체 결합을 통해 생성된 객체의 자원을 효율적으로 관리할 수 있음. 

장식자 패턴은 객체에 새로운 기능을 결합할 때 유용하며, 객체의 동적 조합이 많은 경우에도 편리함

<br/>

**동적 추가**

위임을 통해 객체를 확장하면 동적 객체 확장을 할 수 있는데, 동적 객체 확장이란 **런타임으로 객체에 새로운 책임을 추가할 수 있는 방법**이다. 초기 클래스는 선언에 의해 객체의 내부 구조가 정의됨. 

한 번 클래스로 생성된 객체의 구조를 변경하는 것은 어려움. 하지만 객체를 복합 객체로 구성하면 위임을 통해 객체를 생성한 후에도 동적으로 구조를 변경할 수 있음. 

객체가 확장될 때 사전에 책임이 확정되지 않았어도 적용할 수 있음. 장식자 패턴은 추가하려는 미정의 객체 조합이 많을 때 유용한 패턴

<br/>

**객체에 추가 장식하기**

장식자 패턴은 기존 객체를 확장하기 위해 무언가를 추가 장식한다. 기본 베이스의 객체를 시작점으로 장식을 추가해 객체를 확장함.

<br/>

**객체를 감싸는 래퍼**

장식자는 기본이 되는 객체를 감싸서 새로운 객체로 확장함. 마치 랩으로 감싸는 것과 같다고 해서 래퍼 객체라고도 함. 

장식자 패턴은 기존의 객체를 감싸서 새로운 기능을 추가하는 객체를 생성할 때 매우 유용한 패턴

<br/>

**객체의 투명성**

장식자 패턴으로 확장된 파생 객체는 요청된 행위를 중간에서 가로채 더 확장된 행위로 대신 처리.

확장된 객체는 동일한 인터페이스를 적용함. 클라이언트는 요청된 객체가 원본 객체인지 파생된 객체인지 모르기 때문에 동일한 인터페이스를 사용해 **객체의 투명성**을 부여한다.

투명성은 원본 객체에 영향을 주지 않고 새로운 책임을 추가할 수 있음. 투과적인 인터페이스를 재귀적으로 호출하는 것은 복합체 패턴과 유사함. 장식자 패턴에서도 투명성을 부여해 객체를 확장하는데, 장식자 패턴은 투명성을 응용해 계속 객체를 감싸면서 기능을 확장한다. 하지만 장식자는 복합체와 구조 모양만 유사할 뿐 목적이 다름 

<br/><br/>

### 장단점 및 결과

**장점**

장식자 패턴을 사용하면 상속 형태의 확장보다 더 융통성있게 설계할 수 있음. 

객체 실행 중에서도 동적으로 기능을 추가할 수 있기 때문에 부가 기능을 추가하는 가장 효과적인 방법

미리 클래스 등의 자원을 생성해 낭비하는 것이 아니라, 동적으로 처리되는 시점에 자원을 할당 받아 사용할 수 있음

<br/>

**단점**

작은 단위의 객체가 많이 생성됨

많아지는 객체의 수는 단점이지만, 그렇다고 무조건 단점이라고 할 수는 없음. (작은 코드로 이루어진 객체는 보다 이해하기 쉬우며 상호 작용을 통해 다른 객체를 생성할 수 있는 원소 객체임)

유사한 성질의 작은 클래스가 증가한다. 많은 클래스는 코드를 이해하기 어렵게 만들지만 작은 객체는 완전히 다른 클래스가 아니며 상호 작용하는 방법에만 차이가 있음.

기존 객체를 감싸는 과정이 있어야 하므로 구성 요소를 초기화하는 작업이 필요함

<br/><br/>

### 관련 패턴

**Composite** 

장식자 패턴을 복합체 패턴과 연관시켜 학습하는 것이 좋음. 장식자 패턴이 한 개의 구성을 가진 복합 객체라고 생각하면 복합체 패턴과도 유하산 점이 있음. 차이는 객체를 합성하는 것이 아닌 새로운 객체의 행동을 추가하는 거시

복합체 패턴의 경우 트리 구조로 인해 좌우 폭, 상하 관계 등 다양한 형태의 크기로 확장될 수 있음. 이와 달리 장식자 패턴은 상하 계층으로만 확장된다는 특징이 있음.

<br/>

**Adapter**

언뜻보면 기본 객체에 변화를 추가해 새로운 객체를 생성하는 것이 어댑터 패턴과 유사하다고 생각할 수 있음. 장식자 패턴은 동적으로 기능이 추가되므로 새로운 객체를 생성한다는 의미보다는 어댑터 패턴처럼 새로운 기능을 추가하면서 커지는 구조. 

어댑터 패턴은 인터페이스를 변경하지만 장식자 패턴은 지능, 행동을 변경.

추가하는 기능이 범용적이라면 독립적으로 객체를 구성해 처리하는 것은 차이점이라고 할 수 있음

<br/>

**Strategy** 

장식자 퍝넝니 커지거나 무거워질 때는 전략패턴을 같이 응용하는 것도 좋음. 장식자 패턴은 겉모양을 변경하는 반면, 전략 패턴은 내부의 변화를 가져옴. 또한 전략 패턴은 자신만의 인터페이스에 따라 처리되는 반면, 장식자 패턴은 컴포넌트에서 정의된 인터페이스를 따라 동작함

<br/><br/>

### 정리

장식자의 경우 실행되고 있는 객체가 동적으로 자신의 객체를 확장할 수 있음. 실시간 동작으로 자신의 객체를 확장하면서, 필요로 하는 다양한 책임을 수행하고 문제를 해결해 나감. 

장식자의 기본 배경이 되는 개념은 복합 객체와 위임임. 상속을 배제하고 구성을 통해 객체를 동적으로 확장함.
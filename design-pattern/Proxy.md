## Proxy Pattern

<br/>

> *Provide a surrogate or placeholder for another object to control access to it.*
> 

*다른 객체에 대한 접근을 제어할 대리자<small>surrogate or placeholder</small> 를 제공하는 패턴.*

<br/>

프록시 패턴은 접근을 제어하기 위해 중간 단계에 대리자surrogate를 위치 시키는 패턴.

프록시<small>proxy</small>는 **대리인**을 의미하며, 실체 객체에 직접 접근하지 않고 똑같이 동작하는 **대리자**<small>surrogate</small>를 생성.

프록시는 대리자 객체를 통해 실체 객체를 가로챈 후 대리자 객체로 우회한 접근을 허용함.

<br/>

프록시는 무슨일을 직접 처리하지 않고 대리자를 내세워 처리 - 실체 객체를 호출하면 행위를 중간에 프록시가 가로채서 다른 동작을 수행하는 객체로 변경.

<br/>

객체를 정교하게 제어해야 하거나 객체 참조가 필요한 경우 프록시 패턴을 사용

<br/>

### 프록시 종류

프록시 패턴이 응용되는 범위가 매우 넓음. 대표적인 파생 프록시 패턴은 아래와 같음

✔️ 원격 프록시

✔️ 가상 프록시

✔️ 보호 프록시 

✔️ 스마트 프록시

✔️ 방화벽 프록시, 레퍼런스 프록시, 동기화 프록시 등 ...

<br/>

### 인터페이스

프록시는 동일한 역할을 수행하는 대리자를 생성하고, 대리자는 원본 객체와 동일한 인터페이스를 적용해 투명성을 갖도록 설계됨. 두 객체는 인터페이스를 통해 동일한 규약을 가지며 객체 호출 시 중간에서 행위를 가로챌 수 있음.

프록시는 투명성의 특징을 이용해 객체 분리 작업을 실행하고, 프록시를 위한 인터페이스를 설계함

`Subject` 인터페이스는 실체 객체와 동일한 설계 규칙을 정의함

<br/><br/>

프록시는 실체 객체의 역할을 대신 수행함. 실체 객체와 프록시는 전혀 다른 객체가 아니라 동일한 객체처럼 보이며 그렇게 동작.

프록시는 실체 객체를 대신해 행위를 처리하므로 실체 객체의 정보가 필요함. 프록시에 별도로 저장된 실체 정보를 사용하여 행위를 위임함 (인터페이스를 이용해 프록시 객체를 생성. 프록시 객체를 생성할 때 기존의 실체 정보도 같이 필요함)

<br/>

#### 위임

프록시에서 위임은 프록시 객체와 실체 객체를 연결하는 고리. 의존성 주입을 통해 실체 객체와 프록시 객체를 연결

<br/><br/>

### 투과적 특성

프록시의 객체는 실체 객체와 동일한 동작을 수행함. 프록시는 요청된 동작을 실체 객체로 위임함으로써 동일한 결과를 반환하게 된다.

프록시와 실체 객체는 투명성을 보장하기 위해 동일한 인터페이스를 적용받음

**실체 객체와 동일한 동작을 그대로 대신하는 것**을 **투과적 특성**이라고 함

<br/>

#### 핸들러

핸들러는 투과적 특성을 이용하여 요청된 행위를 처리하는 프록시 동작을 말함

<br/>

### 간접 통로

프록시는 간접화된 객체의 접근 통로를 제공함. 간접 통로는 프록시의 투과적 특성을 이용하여 실체 객체의 행위를 위임하고 처리를 요청함

네트워크 같은 공간에서는 프록시의 투과적 특성을 이용해 원래 객체의 존재를 숨기기도 함. 그래도 실체 객체와 프록시는 동일 객체임

<br/>

### 핸들러 설계

프록시 객체의 내부 설계를 동일하게 유지하는 작업은 매우 번거로움.

→ 개발 중 실체 객체를 수정할 경우도 발생. 실체 객체가 변경되면 인터페이스도 같이 바뀌어야 하고, 인터페이스가 변경괴면 프록시 객체에도 다시 변경된 인터페이스를 적용해야 함. 그럼 또 인터페이스에 맞게 프록시를 수정해야 함. 

이를 위해 **핸들러**를 프록시 안에 추가해야 함.



## 동적 프록시

프록시에는 실체 객체를 숨기는 효과가 있음. 객체를 호출하는 쪽에서는 실행되는 객체가 실체 객체인지 프록시인지 몰라야 함.

<br/>

클라이언트 코드에서는 행동을 처리할 때 프록시와 실체 객체를 구별하지 않음. 

즉 프록시 객체를 생성할지 실체 객체를 생성할지 판단하지 않고 객체를 사용할 수 있어야 함. → 팩토리 패턴을 같이 사용하자.

<br/>

### 팩토리 패턴

클라이언트는 팩토리에 객체 생성만 요청할 뿐이며 반환되는 객체가 프록시인지 실체 객체인지 알 수 없음. 또한 실시간으로 프록시 객체를 동적 생성할 수 있음

<br/>

## 원격 프록시

원격 프록시Remote Proxy는 프록시 패턴을 가장 많이 응용하는 적용 사례이며 주로 **데이터 전달**을 목적으로 사용

<br/>

### 프록시 vs 어댑터

**어댑터 패턴**은 서로 다른 인터페이스를 맞춰주는 반면, **프록시 패턴**은 투과적 특성으로 동일한 인터페이스를 유지함

프록시 패턴은 객체를 분리하는 역할을 하고, **원격 프록시**는 분리된 객체에 투과적 특성을 결합해 객체의 연결을 제어함

<br/>

### 캐싱 처리

웹 HTTP에서 프록시라는 단어를 많이 사용한다. 프록시는 HTTP에서 웹페이지를 캐시 처리함으로써 속도를 개선하고 우회 접속을 시도함

*우회 접속과 에러 처리문을 추가해줌*

<br/>

이처럼 프록시는 어떠한 일을 대신해서 처리함. 객체의 동작을 위임할 수도 있고 변경된 행위를 대신할 수도 있음. 하지만 프록시가 행위를 대리하는 데는 한계가 있음. 

대리로 처리할 수 없는 동작은 본래의 객체로 접근해서 처리해야 하는데, 이것은 프록시의 **투과성**을 의미함.

<br/>

## 가상 프록시

가상 프록시는Virtual Proxy는 프로그램의 실행 속도를 개선하기 위한 패턴.

프록시 패턴을 이용해 무거운 객체 생성을 잠시 유보함

<br/>

### Lazy initialization 게으른 초기화 

일부 프로그램은 내부에서 필요한 객체를 미리 생성하는 작업을 하며 이를 **부트스트래핑 과정**이라고 함.

초기화 작업은 프로그램이 시작될 때 관련성있는 객체 생성들을 처리해야 하므로 실행 지연이 발생함

사실 기동 시 모든 객체를 생성하는 것보다 필요할 때마다 객체를 생성해 사용하는 것이 더 효과적

가상 프록시 패턴은 실제로 동작하는 객체를 생성하지 않고, 필요 시점에서 객체를 동적으로 생성하도록 프록시 객체로 대신 연결함. 가상 프록시는 게으른 초기화lazy initialization와 유사함

<br/>

프로그램 실행 시 객체를 초기화하는 작업은 많은 시간을 소모하는데, 객체 생성 수가 많을 수록 기동 시간이 느려짐. 

그렇다고 생성된 모든 객체를 즉시 사용하지는 않음. 사용 빈도가 낮은 객체까지 생성까지 초기화 과정에서 실행됨으로써 불필요한 지연 시간이 발생하기도 함. → **가상 프록시**를 사용해서 보완해보자

가상 프록시는 실체 객체 생성보다 더 빨리 객체를 생성, 반환할 수 있음

가상 프록시는 프로그램에 껍데기만 있는 객체를 전달함. 가상 프록시를 통해 실체 객체의 접근이 필요할 때 원본 객체를 동적으로 생성하여 프록시와 연결함. → **동적 연결 방식**: 초기화 작업에서 오래 걸리는 객채를 처리할 때 유용함

객체의 초기화 작업으로 지연되는 시간 없이 빠르게 코드 작업을 수행 할 수 있음

<br/>

인스턴스화는 객체를 생성하고 메모리 자원을 할당 받기 위해 컴퓨터 내부 연산을 필요로 함.

객체를 생성하는 연산량에 따라서 약간의 지연시간이 발생하는데, 가상 프록시를 사용하면 즉시 필요한 객체를 제외하고는 객체의 실행 시간을 줄일 수 있음

<br/>

## 보호용 프록시

프록시 패턴의 또 다른 적용 사례로 **통제 제어 목적**이 있음

<br/>

객체를 사용하기 위해서는 생성 과정과 자원 할당이 필요함. 하지만 객체에 접근 권한이 없는 사람이 프로그램을 사용하고자 할 때 제한된 객체 생성까지 할 필요는 없음. 

권한이 없는 객체를 생성 과정에서 배제하면 자원 낭비를 줄일 수 있음.

프록시를 통해 먼저 제어권을 확인한 후, 실제적인 객체를 생성하는 것이 좋음

<br/>

### 보호용 프록시 vs 장식자

객체를 동적으로 확장하여 실행할 수 있다는 점에서 유사함. 장식자 패턴의 목적이 새로운 기능을 추가하는 것이라면, 보호용 프록시는 접근을 제어하기 위해 코드를 추가하는 것.

<br/>

## 스마트 참조자

프록시는 실체 객체에 접근할 때 추가 행위를 부여하여 호출할 수 있음

스마트 참조자 smart reference는 장식자 패턴과 유사하게 객체를 동적으로 확장 응용하는 기법임

<br/>

**스마트 참조자 프록시**smart reference proxy : 실체 객체를 호출하여 행동을 수행하기 전에 프록시 내부에 어떤 작업을 같이 추가해서 실행하는 경우.

<br/>

<br/>

## 정리

프록시 패턴의 특징은 투명성을 이용해 객체를 분리하여 재위임한다는 것.

분리된 객체를 위임함으로써 대리 작업을 중간 단계에 삽입할 수 있음. 

프록시 패턴은 세밀한 객체의 접근이 필요할 때도 유용함

<br/>
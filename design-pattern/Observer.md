## Observer Pattern

# 감시자


상태값을 하나하나 관찰하면서 동작하는 것은 비효율적이며, 성능을 저하시키는 요인

직접 상태값을 관찰하는 것이 아니라 수동적으로 상태값을 전달 받아 처리하는 패턴이 바로 감시자<small>Observer</small> 패턴

<br/>

관찰이 아닌 통보


관찰 : 반복문 + 조건문을 이용한 감시 코드 - 코드의 로직이 다른 값(상태)에 의존해서 동작하는 경우

<br/>

통보 : 직접 상태값을 관찰하지 않고 수동적으로 상태값을 전달 받는 방법은 바로 상태가 변경됐을 때 통보해주는 것. 감시자 패턴에는 주체 <small>Subject</small> 라는 구성 요소가 있음

<br/>

주체 클래스는 상태를 갖고 있고, 이 상태에 변경이 발생했을 때 **실제 동작하는 객체(Observer)에 통보하거나 갱신 작업**을 통보

→ 실제 동작하는 객체는 주체의 상태값을 직접 관찰하지 않고도 상태 변화를 알 수 있음

<br/>

✔️ 감시자 패턴은 **상태를 감시하는 행동**과 **실제 동작**을 처리하는 행동을 분리해서 구현

<br/>

## 할리우드 원칙

객체지향의 설계 원픽 중 할리우드 원칙이라는 것이 있는데, 영화 산업으로 유명한 할리우드에서 배우를 캐스팅하는 과정 객체에 비유한 데서 만들어진 원칙

<br/>

> 배우가 영화에 출연하기 위해 자신의 프로필을 영화사에 전달한다. 그리곤 캐스팅 상태를 지속적으로 물어보는데, 영화사 입장에서는 매일 연락하는 배우들에게 캐스트이 상태를 통보해주기 어려움
> 
> 
> 그래서 영화사는 모든 배우에게 “앞으로 연락하지 말고 캐스팅되면 저희가 연락 드리겠습니다”라고 공지하고, 배우는 캐스팅 상태를 영화사에 물어보지 않은 채 통보를 기다리는 것. 다른 비유로는 입사시험을 치른 후 합격통지를 기다리는 취업 준비생을 들 수 있음.
> 

<br/>

감시자 패턴은 할리우드 원칙을 적용한 패턴 구현

<br/>

## 구성

<br/>

크게 4가지 클래스로 구성

- 주체 subject
- 실제 주체 concreteSubject
- 감시자 observer
- 실제 객체 concreteObserver

<br/>

통보 역할 : 주체 & 실제 주체

처리 역할 : 감시자 & 실체 객체

<br/>

### 주체 & 실제 주체

주체-실제 주체는 감시자 패턴에서 객체의 등록, 삭제, 통보를 담당하는 클래스

주체 클래스는 실제 처리하는 객체를 관리하고 관리를 담당하는 주체(Subject)는 1개 이상의 감시자 객체를 갖고 있음

<br/>

### 감시자 & 실제 객체

감시자-실체 객체는 통보를 수신 받아 처리하는 객체. 통보를 받으려면 주체 클래스에 수신 받는 객체를 등록해야 함 

보통은 주체로부터 수동적으로 통보를 받지만, 필요 시 능동적으로 서브 객체 상태를 주체로 전달하기도 함

<br/>

### 이벤트

감시자 패턴은 이벤트를 처리하는 패턴과 유사하며 주체 클래스는 이벤트를 중재하는 객체와 같음.

상태값이 이벤트라면 상태는 이벤트를 받아 감시자 객체에 전달하는 역할을 함

감시자 패턴은 분산 이벤트 핸들링 처리를 수행

<br/>

### 감시자 객체의 의존성

객체가 관계를 가진다는 것은 의존성을 의미함

메인 객체가 서브 객체를 필요로 하고, 서브 객체에 동작 메세지를 전달함

메인 구성 요소인 주체는 처리해야 하는 복수의 서브 객체(Observer)를 갖고 있음

주체-감시자가 하나의 커다란 객체 덩어리로, 복합 구조(Composite) 객체라고 함

주체와 감시자 간 의존 관계를 갖고 있기 때문에 다른 말로 종속자Dependent 패턴이라고도 함

<br/>

### 등록

모든 객체(Observer)는 주체에 등록되어야 함

주체는 필수 메서드를 갖는데, 이를 통해 관계를 설정하기 위한 등록을 요청함

주체에 등록된 감시자는 언제든지 증록과 제거가 가능

필수 메서드는 인터페이스로 적용하여 구현을 일반화하고, 일반화된 인터페이스는 상태 변화 시 주체에 등록된 감시자로 통보를 전달

<br/>


### 느슨한 결합

이벤트 통보를 받는 실제 (Observer) 객체를 주체에 등록

감시자 패턴은 객체의 결합을 보완하기 위해 관계를 동적으로 형성하여 느슨한 결합 구조로 구성 (감시자 패턴의 경우 하나의 커다란 복합 구조 객체로 설계하기 때문)

<br/>


### 독립적

독립적인 실행은 다른 객체의 클래스에 의존하지 않고도 메시지를 전달할 수 있는 것이며, 감시자 패턴의 장점

주체와 감시자는 느슨한 형태의 결합 구조와 의존성을 가짐.

주체는 상태 변화 시 감시자에 변경된 상태만 전달하면 됨. 

모든 감시자 객체는 주체에 의존하는 관계지만, 때로는 독립적 실행이 가능한 개별 객체

<br/>

### 일대다 관계(1:N)

하나의 주체는 다수의 객체를 가지며 일대다 관계라고 말함. 일대다 구조는 복합 구조 객체가 됨

상태 변화가 발생하면 주체는 등록된 모든 감시자 객체에 변경을 통보하는데, 반복문을 사용하며 통보를 하기도 하고 이를 푸시형 통보라고 함

주체와 객체간에는 상호 작용이 발생하며, 모든 감시자는 주체에 의해 갱신되기를 기다리고 있음

<br/>

### 구독 관계

일대다 구조의 감시자 채턴에서는 주체가 변화 상태를 모든 객체에 **일방적인 단방향성으로 통보**함

단방향성을 가진 감시자 패턴을 다른 말로 **게시-구독publish-subscribe** 패턴이라고 함

어떤 UI 프레임워크에서는 감시자 패턴을 **리스너 패턴Listener Pattern** 이라고도 부름

<br/>

### 복합 관계

하나의 주체는 여러 개의 감시자 객체를 가짐. 감시자 패턴은 커다란 복합 구조의 객체 덩어리

<br/>

## 주체

주체는 인터페이스subject와 실제 주체concreteSubject로 이뤄짐

<br/>

### 주체 인터페이스

```java
public interface Subject {
	void addObserver(Observer obs);
	void deleteObserver(Observer obs);
	void notiObserver(String msg);
}
```

<br/>

### 실제 주체

```java
public class Members implements Subject { 
	private ArrayList<Observer> objs; 

	public Members() { 
		objs = new ArrayList<>(); 
	} 
	
	@Override 
	public void addObserver(Observer observer) { 
		objs.add(observer); 
	}
	
	@Override 
	public void deleteObserver(Observer observer) { 
		int index = objs.indexOf(observer); 
		objs.remove(index); 
	}
	
	@Override
	public void notiObserver() { 
		for(Observer obj : objs) { 
			obj.update(msg); 
		}
	}
}
```

<br/>

### 감시자 보관

```java
// 감시자 보관
private ArrayList<Observer> objs;
```

실제 주체는 배열 저장소에 감시자 객체를 보관하고, 필요시 객체의 정보를 참조

저장되는 배열은 `private` 접근자 속성을 갖기 때문에 객체를 저장하려면 `setter` 메서드를 같이 생성해야 함

<br/>

### 관리 메서드

실제 주체는 인터페이스의 구현을 적용 받음

<br/>

### 호출

실제 주체는 감시자의 등록을 관리하고 외부로부터 상태 변화나 이벤트를 수신하며 수신된 상태를 등록된 모든 감시자 객체에 통보

<br/>

## 감시자

감시자 객체 - 실제 동작을 처리

<br/>

### 감시자 인터페이스

감시자는 주체로부터 통보되는 상태를 수신 받아 동작

각각의 감시자 객체는 주체와 상호 작용할 수 있는 공통된 메서드가 필요하며 이를 위해 인터페이스를 적용

개별 감시자를 생성하기 위한 인터페이스를 설계

<br/>

```java
public interface Observer {
	void update();
}
```

<br/>

### 감시자 객체

감시자 객체<small>ConcreteObserver</small>는 감시자 인터페이스를 상속하고 이를 구체화함. 감시자 객체는 요청 받는 실행 객체

```java
public class UserA implements Observer { 
	private String name;

	public UserA(String name) {
		this.name = name;
	}

	@Override 
	public void update() { 
		System.out.println(name + " 갱신됩니다."); 
	}
}
```

<br/>

생성된 모든 감시자 객체는 공통된 인터페이스 및 추상화를 통해 일관성을 유지하고, 동일한 상태값을 저장

<br/>

### 통보 시스템

통보는 크게 수동적 통보와 능동적 통보로 구분하는데, 감시자 패턴은 수동적 통보 방식으로 감시자에게 전달하며, 감시자 객체로부터 상태 변화 메시지를 수동적으로 기다림

<br/>

### 브로드캐스팅

감시자 객체는 감시자 패턴에서 수동적인 상태 변화 메시지를 수신하며, 메시지를 수동적으로 수신한다는 측면에서 브로드케스팅 통보와도 유사함

브로드캐스팅 방식의 단점은 불필요한 객체에도 메시지를 전달.

등록된 모든 객체로 전달하다보면 예측하지 못한 잘못된 동작이 발생할 수 있음

<br/>

### 능동적 통보

감시자 패턴은 주체를 통해 상태 변화를 모든 감시자 객체에 통보

감시자 객체가 메시지 수신만 받는 것은 아니며, 때로는 자신의 변화를 주체에게 능동적으로 통보하고, 주체는 하위 감시자 객체가 통보한 상태를 다른 감시자 객체에 통보할 수 있음 → 결합 관계를 통해 상호 간 정보를 교류할 수 있지만, 객체 간 호출 순환 고리에 빠지지 않도록 주의해서 설계

<br/>

### 상태 저장

감시자 패턴은 수동적, 능동적 통보가 모두 가능하도록 설계할 수 있는데, 더욱 긴밀한 관계를 설정해야 한다.

상태가 변화할 때마다 감시자에 매번 통보하는 것이 아니라 특정한 상태의 조건이 발생했을 경우에만 통보를 전달하고 상태를 판별하기 위해 상태 플래스를 추가로 사용

<br/>

## 동작 실습

### 메인 동작

```java
public class Main { 
	public static void main(String[] args) { 
		Members subject = new Members(); 
		UserA userA = new UserA("Jiny");
		UserB userB = new UserB("Reilly");

		subject.addObserver(userA);
		subject.addObserver(userB);

		subject.notiObserver();
	} 
}
```

<br/>

### 감시자 생성과 등록

<br/>

### 상태 변경과 통보

<br/>

### 상태 보관

주체가 모든 상태를 감시자 객체에 전달하는 과정에서 많은 부하가 발생. 주체는 특정 상태만 검출하여 감시자에 통보할 수 있음

주체는 발생한 상태값을 보관하고 보관된 상태값을 조건 처리하며, 조건이 성립된 경우에만 감시자 객체에 통보를 전달함

<br/>

### 비동기와 스레드

<br/>

## 활용

감시자 패턴은 상태를 직접 관찰하지 않고 불특정 다수의 객체에 통보할 때 유용함

<br/>

### 불특정 대상

통보하는 객체의 수를 상관하지 않음 

주체는 등록된 모든 감시자 객체에 통보할 수 있어 자신의 변화를 불특정 다수의 객체에게 통보할 수 있음

<br/>

### 언어 지원

자바에서는 API형태로 observer 인터페이스와 observable 클래스를 사용할 수 있음

통보는 푸시<small>push</small> 방식과 풀<small>pull</small> 방식 모두 지원

<br/>

## 관련 패턴

감시자 패턴은 다른 패턴을 구현할 때 같이 응용되는 경우가 많음

행동들이 유사한 성격을 갖기도 하지만, 해결하고자 하는 목적에는 조금씩 차이가 있음

|  |  중재자 패턴 | MVC |
| --- | --- | --- |
| 유사성 | 중재자도 객체에 발생한 상태를 다른 객체에 전달. 직접 통신하는 것이 하니라 중심 객체가 통신을 중재 → 감시자 패턴을 함께 사용. 상태 변화를 통보하는 측면에서 봤을 때 유사 | 모델이 주체에 해당하고 뷰가 감시자 역할을 수향하는 구조로 설계됨 |
| 차별성 | 감시자 패턴은 상태만 통보하고 중재자 패턴은 역할 조정을 목적으로 통보 |  |

<br/>

## 정리

감시자 패턴은 객체의 상태 변화를 다른 객체에 통보하는 패턴, 또는 감시자를 통해 자신의 상태를 다른 대상의 객체에 통보할 수도 있음

감시자 채턴은 매번 상태를 관찰하는 것이 아니라 상태가 변경됐을 때 통보함으로써 작업을 처리

감시자는 언제든지 메서드를 통해 통보를 전송할 수 있음
## Builder Pattern

<small>*p. 244*</small>

<small>| **한 줄 소개** | 복잡한 객체의 구조와 접근을 간단하게 표현하는 방법 </small>

<br/>

빌더 패턴은 추상 팩토리를 확장하여 크고 복잡한 객체를 생성할 수 있음

<br/>

## 5.1 건축물

builder의 사전적 의미는 ‘건축물을 짓는 사람 또는 회사’

즉 커다란 구조의 큰 물체를 설계하고 만드는 것을 의미함

<br/>

### 5.1.1 객체 생성

생성 패턴의 주요 목적은 **객체의 생성 과정을 한 곳에 집중화**하는 것.

패턴을 사용하여 객체의 생성 관리하는 이유는 인스턴스화 과정에서 발생하는 강력한 의존 관계를 해소하기 위함

객체 지향에서 객체의 종류 - 단일 객체, 복합 객체

기본적으로 클래스는 하나의 객체. 단일 객체란 하나의 클래스로 생성된 객체

객체는 데이터와 행동을 가지며 때로는 객체를 확장하기 위해 상속 구조를 적용 (팩토리, 팩토리 메서드, 추상 팩토리 모두 단일 객체)

<br/>

### 5.1.2 복합 객체

상속 - 전형적인 클래스 확장 방식

상속은 상위 클래스를 is-a 관계로 포괄하여 큰 규모의 객체를 생성하는 기법

상속에서는 강력한 상하 결합 관계와 불필요한 모든 행위까지 포함된다는 단점도 있음

객체 지향에서는 상속의 단점을 개선하기 위해 의존성 주입을 사용. 의존성을 통해 복합 객체를 생성하여 사용하는 것을 권장함. 복합 객체란 하나의 객체가 다른 객체를 포함하는 관계 구조

복합 객체는 구조적 의존 관계를 통해 객체를 확장함

<br/>

복합 객체는 **객체가 생성된 후에도 다른 객체와 관계를 설정해 동적 확장할 수 있다는 장점**을 가짐

많은 디자인 패턴의 원리와 목적은 **상속 결합을 배제하고 의존 관계의 복합 객체로 변경하여 처리**하는 것

<br/>

### 5.1.3 복잡한 객체

복합 객체는 내부적으로 다른 클래스의 객체를 포함하고 관계 설정을 추가로 해줘야 하므로 객체를 생성하는 과정이 단일 객체보다 복잡함

복합 객체를 생성할 때는 객체의 구조 순서에 맞게 단계별로 실행됨

복합 객체 사용을 중요시하는 것이 최신 객체 지향 트렌드이지만 팩토리, 팩토리 메서드, 추상 메서드 패턴으로는 복합 객체를 생성할 수 없음

기존 생성 패턴의 한계로 인해 복합 객체 생성을 처리할 수 있는 또 다른 패턴이 필요해졌고, 빌더 패턴은 복잡한 구조의 복합 객체를 생성하는 로직을 별도로 분리하여 객체 생성을 처리함

<br/>
## 5.2 객체 실습

복합 객체는 하나의 객체가 다른 클래스의 객체를 초함한다는 특징을 가짐

<br/>

### 5.2.1 기본 클래스

<br/>

### 5.2.2 객체의 구성

복합 객체는 다른 클래스의 객체를 포함

복합 객체가 다른 객체를 갖는 방법은 다양한데, 먼저 내부적으로 직접 관련된 클래스의 객체를 생성할 수 있음

객체 생성자를 통해 관련 있는 객체들을 생성 결합할 수  있으며, 간단한 팩토리 패턴과 같이 메서드를 활용해 관련된 객체를 생성할 수도 있음

객체를 직접 생성하는 방법 외에 외부로부터 객체의 의존성을 전달받을 수도 있음

디자인 패턴에서 복합 객체의 구성은 의존성 주입 형태가 권장되며 의존성 주입이 이루어진 객체들은 복합 객체의 내부 프로퍼티에 저장됨. 기본 객체 안에 선언된 속성 프로퍼티는 외부에서 전달받은 객체를 담음

프로퍼티에 저장된 객체는 속성에 따라 접근을 제한(접근지정자)할 수 있음

의존성 주입이 이루어진 객체의 접근 권한을 설정할 때는 몇 가지 로직이 추가됨

private, protected 속성은 외부에서 프로퍼티에 직접 접근할 수 없음. 접근 권한 관리를 위한 별도의 메서드(getter, setter)를 추가해야하지만, 코드의 양이 늘어나고 번거로움

하지만 객체의 접근을 제한하고 은닉성을 가질 수 있다는 점에서 같이 작성하는 것이 좋음

<br/>

### 5.2.3 부속 클래스

<br/>

## 5.3 빌더

빌더 패턴은 복잡한 구조를 가진 복합 객체의 생성 과정을 분리하여 처리하는 패턴

복합 객체의 생성 과정을 단계별로 분리함으로써 복합 객체의 생성을 일반화할 수 있음

<br/>

### 5.3.1 빌더 패턴

팩토리 패턴도 요청한 객체의 생성 과정을 분리. 요청된 복합 객체의 생성을 처리하기 위해 별도의 독립된 클래스를 준비하고, 생성 패턴은 요천되는 모든 객체를 생성하며 반환하는 역할을 수행함. 팩토리 패턴은 단일 클래스의 객체만 생성, 반환하므로 요청된 객체가 복합객체일 경우 팩토리 패턴을 적용할 수 없음

복합 객체는 동적으로 객체를 확장할 수 있어 보다 효율적임

하나의 객체는 여러 객체를 포함하며 포함된 객체는 또 다른 객체를 포함할 수 있음

복합 객체는 계층적인 구조 관계를 가지는데, 이 특징 때문에 복합 객체를 생성하는 것이 쉽지 않음. 복합 객체의 내부 구조는 상하로 확장되기도 하고 다수의 leaf를 가지기도 함. 복잡한 구조를 가진 복합 객체를 하나의 방식으로 정의하기는 매우 어려우며 목적에 따라 수없이 많은 종류의 복합 구조가 탄생할 수 있음

다양한 구조의 복합 객체를 패토리 패턴으로 구현하기에는 한계가 있음. 따라서 각 구조에 맞게 생성을 처리할 수 있도록 과정을 분리하여 처리함

<br/>

### 5.3.2 생성 로직

복잡한 구조를 가진 복합 객체를 한 단계로만 생성할 수는 없음

복합 객체의 내부 구조에 맞게 단계별로 객체 생성을 분리하고 관계를 결합하는 과정이 필요함

복합 객체의 구조는 종속적이기 때문에 종속된 순서의 역순으로 객체를 생성하여 결합해야 함

복합 객체에는 구조에 맞게 객체를 생성하고 관계를 설정하는 로직이 필요

생성 로직은 일반적으로 클라이언트 코드 안에 작성됨

복합 객체의 생성 로직을 일반 코드로 작성하면 객체 생성 과정을 효율적으로 관리하기 어려움

그래서 빌더 패턴은 복합 객체 생성 과정을 별도의 독립된 클래스로 관리

<br/>

### 5.3.3 빌더 추상화

빌더 패턴은 추상화를 통해 다양한 종류의 복합 객체를 생성하고 관리함.

```java
public abstract class Builder {
	protected Algorithm algorithm;
	
	public Builder setAlgorithm(Algorithm algorithm) {
		System.out.println("빌드 객체를 저장합니다.");
		this.algorithm = algorithm;

		return this;
	}

	public getInstance() {
		return this.algorithm.getInstance();
	}

	public abstract void build();
}
```

추상 클래스인 Builder는 추상 메서드 build()를 선언. build()는 복합 객체를 생성하는 로직을 하위 클래스에 위임

<br/>

### 5.3.4 ConcreteBuilder

추상 클래스로 설계된 빌더는 자체적으로 객체를 생성할 수 없어 추상 클래스를 상속하는 하위 클래스(ConcreteBuilder)가 필요합니다. 하위 클래스는 실제 복합 객체의 생성과정을 위임받고, 빌더 로직을 구체화하는 하위 클래스(ConcreteBuilder)는 상위 추상 클래스(builder)를 상속받습니다.

하위 클래스는 상위 클랫에서 선언된 추상 메서드의 실제를 구현함. 추상 메서드는 인터페이스와 같아서 추상메서드를 다시 오버라이드하여 구현하는데, 구현하지 않을 경우 오류가 발생

```java
class Factory extends Builder {
	public Factory(Algorithm algorithm = Null) {
		System.out.println("객체를 생성하였습니다.");	
		if (algorithm) {
			this.algorithm = algorithm;
		}
	}

	public Factory build() {
		System.out.println("-- 빌드 --");	
		this.algorith.setCpu("i7");
		this.algorith.setRam({8, 8});
		this.algorith.setStorage({256, 512});

		return this;
	}
}
```

추상화를 적용하면 여러 개의 하위 클래스를 만들어 다형성을 적용할 수 있음

다형성을 이용해 다양한 복합 객체의 생성 로직을 하위 클래스로 구현할 수 있음

<br/>

### 5.3.5 추상 메서드

빌더 패턴은 추상 메서드를 통해 복합 객체 생성 방법을 달리 적용할 수 있음

빌더 패턴은 복합 객체의 생성 로직을 직접 클라이언트 코드로 구현하거나 메서드를 호출하지 않으며, 독립적인 단계별 구축 공정을 분리하여 처리

추상 메서드 build() 안에는 복합 객체 생성을 위한 처리 로직들이 들어 있으며 빌더 생성 로직을 별도의 알고리즘으로 분리하여 외부로부터 주입받을 수도 있음

빌더 패턴은 다양한 종류의 복합 객체 생성 로직을 구분

추상 메서드와 외부 알고리즘을 통해 객체의 실제 생성 로직을 외부로부터 숨기는 효과도 있음

<br/>

## 5.4 알고리즘

빌더 패턴은 복합 객체의 생성 로직을 별도 클래스로 분리하며 분리한 로직을 알고리즘이라고 부름

분리한 알고리즘 객체는 다시 빌더에 전달되어 복합 객체를 생성

<br/>

### 5.4.1 전략 패턴

복합 객체는 생성 과정이 복잡함.

```java
	public ConcreteBuilder() {
    System.out.println("객체를 생성합니다.");
    this.algorithm = algorithm;
  }
```

알고리즘은 전햑 패턴에서 생성자를 통해 의존성을 주입함

의존성을 전달받은 전략 패턴은 내부 프로퍼티에 저장되며 외부로 공개된 메서드를 통해 실행됨

실체 객체 생성을 요청하는 것과 객체를 생성하는 알고리즘이 분리된 것을 볼 수 있음

빌더 패턴은 전략 패턴의 알고리즘을 응용하여 복합객체를 생성함

<br/>

### 5.4.2 추상화

복합 객체를 생성하는 방법은 다양함. 다양한 객체를 생성하기 위해서는 다형성을 적용하는 것이 좋은데, 빌더 체턴은 일관적인 알고리즘을 적용하면서 다형성을 유지하기 위해 추상화 구조를 적용

빌더 패턴은 추상 팩토리를 확장한 패턴. 알고리즘은 다시 추상화를 통해 생성 과정을 단계별로 캡슐화

추상화된 알고리즘은 각각의 단계를 구조화하여 객체를 생성할 수 있는 로직으로 전달됨

```java
public abstract class Algorithm {
    protected Computer composite;

    public abstract Algorithm setCpu(String cpu);
    public abstract Algorithm setRam(ArrayList<Integer> ram);
    public abstract Algorithm setStorage(ArrayList<Integer> storage);

    public Computer getInstance() {
        return this.composite;
    }
}
```

```java
public class ProductModel extends Algorithm {

    public ProductModel() {
        System.out.println("ProductModel 객체 생성");
        this.composite = new Computer();
    }

    public ProductModel setCpu(String cpu) {
        System.out.println("CPU 설정");
        this.composite.cpu = cpu;
        
        return this;
    }

    public ProductModel setRam(ArrayList<Integer> ram) {
        System.out.println("RAM 설정");
        this.composite.ram = ram;

        return this;
    }

    public ProductModel setStorage(ArrayList<Integer> storage) {
        System.out.println("CPU 설정");
        this.composite.storage = storage;

        return this;
    }
}
```

알고리즘의 하위 클래스에는 복합 객체를 생성하기 위한 단계별 행동이 정의되어있음

실제 제품을 만들 때나 중간에 과정을 추가 확장할 때 매우 유용

빌더 패턴을 구현할 때에는 먼저 생성 및 조합하기 위한 모델을 만들어야 함

<br/>

### 5.4.4 교환 가능성

객체 지향에서는 복합 객체의 구조가 너무 다양하기 때문에 활용하기 어려움

빌더패턴에서는 이를 보완하기 위해 생성과 처리 로직을 분리했고, 처리 로직을 분리할 때 전략 패턴을 사용함

생성 단계를 위한 알고리즘을 전략 패턴으로 전달함에 따라 다양한 종류의 복합 객체를 쉽게 생성할 수 있게 되었음

전략 패턴은 생성자를 통해 알고리즘 객체를 전달(의존성) 받음. 따라서 빌더 클래스는 어떤 복합 객체가 만들어지는지 구체적으로 알지 못함

이미 약속된 동작으로만 객체 생성과정을 호출하고, 실체 객체는 알고리즘에 의해 생성됨

빌더 패턴은 언제든지 전달되는 알고리즘을 교체하여 다양한 복합 객체를 동적으로 생성할 수 있음

<br/>

### 5.4.5 빌더 선택

알고리즘만 사용하여 가양한 복합 객체를 생성하는 것이 충분하지 않을 때도 있음

알고리즘은 빌더 클래스에서 정의된 단계별로 동작을 호출하여 복합 객체를 생성

만약 단계가 변경된 다른 복합 객체 생성이 필요한 경우, 다수의 ConcreteBuilder 하위 클래스를 구성하여 그룹을 생성할 수 있음.

<br/>

## 5.5 생성 요청

<br/>

### 5.5.1 알고리즘 생성

<br/>

### 5.5.2 빌더 객체

복합 객체를 제작하는 빌더 객체를 생성함 빌더 패턴 내부에는 복합 생성을 수행할 수 있는 알고리즘이 있으며, 이 알고리즘은 전략 패턴을 결합하여 구현 동작됨

전략 패턴인 알고리즘을 빌더의 생성자로 하여 의존성 주입함. 생성자를 통해 의존성 주입이 이뤄지면 입력된 알고리즘으로 복합 객체를 생성하는 동작을 수행함

혹은 setter 메서드를 통해 알고리즘을 주입할 수도 있음. 

<br/>

### 5.5.3 빌드

빌더 패턴을 이용하면 보다 쉽게 복합 객체를 생성할 수 있음. 빌더 객체는 어떤 복합 객체가 생성되는지 알지 못하며, 빌더로 생성되는 복합 객체의 종류는 알고리즘에 의존함

알고리즘을 변경하면 다양한 복합 객체를 생성할 수 있음. (전량 패턴과 유사)

<br/>

## 5.6 관련 패턴

빌더는 추상화를 통해 다양한 복합객체를 생성

실제 복합 객체의 생성 로직을 분리하며 필요에 따라 다양하게 로직을 변경할 수 있음 

<br/>

### 5.6.1 템플릿 메서드

빌더 패턴의 Builder는 객체를 건축하는 행위히며 실제로 객체 생성 로직을 분리함

상위 클래스에는 추상 메서드를 선언하기만 하고, 하위 클래스에는 실제 구현 메서드를 오버라이드함

<br/>

### 5.6.2 복합체 패턴

빌더는 복잡한 복합 객체를 생성함. 복합 객체는 다름 객체를 포함하며 복합체 패턴과 유사한 구조를 가짐

<br/>

### 5.6.3 추상 패터리

빌더 패턴은 추상화 작업으로 다양한 복합 객체의 생성 그룹을 만들 수 있음. 추상화를 통해 그룹을 관리하는 것은 추상 패토리와 유사함. 빌더 패턴은 추상 팩토리를 확장하여 복합 객체를 생성함

<br/>

### 5.6.4 파사드 패턴

빌더 패턴은 복잡한 객체를 생성함

복합 객체의 생성 로직은 Builder 객체에서 조합함

하지만 외부에서는 빌더 패턴이 복합 객체를 생성하는 내부 구조를 알지 못함

클라이언트는 빌더 패턴의 복잡한 구조를 알 수가 없으며, 외부에 공개된 생성 메서드만 호출하면 복합 객체를 생성할 수 있음

API와 같은 파사드 패턴과 유사함 

<br/>

## 5.7 정리

빌더 패턴은 추상 팩토리 패턴을 확장하고, 복잡한 단계를 가진 복합 객체를 생성할 수 있음.

빌더 패턴은 생성 단계를 중점으로 설계하고, 추상 팩토리 패턴은 유사한 객체의 생성 과정을 중심으로 제품군을 설계함

빌더 페턴은 추상 팩도리에서 유사한 객체의 제품군을 알고리즘화하여 다양한 복합 객체를 생성, 관리하는 용도로 사용. 빌더는 관계된 서브 객체의 단계별 생성 절차가 완료된 후 복합 객체를 생성 및 반환함. 하지만 추상 팩토리는 객체를 생성한 즉시 반환함

빌더 패턴의 경우 만들고자 하는 부품들이 모여야 의미가 있고, 추상 팩토리 패턴은 각각의 부품에만 의미를 부여함
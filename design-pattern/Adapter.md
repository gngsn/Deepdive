## Adapter Pattern

<small>| **한 줄 소개** | 인터페이스를 추상화하여 서로 다른 인터페이스를 통일화. 상속을 통한 어댑터와 합성을 통한 어댑터로 구분.</small>

코드를 재사용하기 위해 구조를 변경하는 패턴

<br/>

> Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.

<br/>

### 예제 코드로 미리 살펴보기

예제 소개 : 전체, 이미지, 뉴스, 지도 탭 검색바(`Search`)에 **동영상**(`FindMovieAlgorithm`)을 추가하려고 하는데 다른 회사에서 만들어서 호환이 되지 않음.

-> `SearchFindAdapter` 객체를 제작해 기존의 코드(FindMovieAlgorithm)를 재활용

<details>
<summary> Client Code </summary>

``` java
package strategy.after;

interface ISearch {
  public void search ();
}

class Search implements ISearch {
  public void search () {
      System.out.println("SEARCH ALL");
  }
}

class SearchStratagyImage implements ISearch {
  public void search () {
      System.out.println("SEARCH IMAGE");
      // 이미지검색하는 코드
  }
}

class SearchStratagyNews implements ISearch {
  public void search () {
      System.out.println("SEARCH NEWS");
      // 뉴스검색하는 코드
  }
}


```

</details>

<details> 
<summary> Adaptee Code </summary>

``` java
package adapter.search;

interface FindAlgorithm {
  public void find (boolean global);
}

class FindMovieAlgorithm implements FindAlgorithm {
  public void find (boolean global) {
      System.out.println(
        "find movie" + (global ? " globally" : "")
      );
      // 동영상검색하는 코드
  }
}
```

</details>

<details> 
<summary> Adapter Code </summary>

``` java
class SearchFindAdapter implements SearchStrategy {
  private FindAlgorithm findAlgorithm;

  public SearchFindAdapter (FindAlgorithm _findAlgorithm) {
    findAlgorithm = _findAlgorithm;
  }
  public void search () {
    findAlgorithm.find(true);
  }
}
```
</details>

<br />

### 오래된 코드

뉴턴과 거인의 어깨 이야기 → 대부분의 현대 기술은 이전 세대의 노력으로 만들어짐. 어느날 갑자기 창조된 것이 아니다.혀재의 코드는 처음 컴퓨터가 탄생한 순간부터 누적된 코드라고 할 수 있음. 새로운 기능을 만들기 위해 오래된 코드를 참고하거나 기존의 코드를 재사용. 즉, 이전 코드를 재사용하면서 새로운 코드를 재창조하는 것

<br />


- 잘못된 코드

    : 개발을 하다보면 개발 당시에는 발견하지 못했던 문제가 나중에 발견되기도 하고, 그 당시에는 정상적이었던 동작이 환경 변화로 인해 문제가 되는 경우도 많다.

- 코드의 변화
  
  : 컴퓨터의 기능과 코드는 단계별로 발전. 기능이 진화하면서 기존 콘드를 재사용 → 코드를 재사용하면 기능 구현 시 많은 시간과 노력을 줄일 수 있음

<br />

하지만 모든 코드를 재사용할 수는 없고, 코드 스타일의 변화나 사회적 변화, 고객 요규 변경 등 수많은 변화 요인으로 인해 코드를 재사용 할 수 없도록 방해하는 요인이 된다.

개발자는 변화를 예측하고 예측에 맞춰 코드를 설계하지만 모든 상황을 완벽히 예측하여 설계할 수는 없음

미세란 동작 변화, 데이터타입 불일치, 매개변수 인자값 불일치, 반환값 타입 등 다양한 차이가 발생하기 때문에 코드를 재사용하기 위해서는 변환(변형) 작업이 필요함.


<br />

인터페이스의 차이가 있다면 기존 코드를 사용할 수 없음 → 인터페이스가 일치하지 않는 문제는 협업을 하면서 여러 개발자들 사이에서든, 외부 요인에 따라 어디서든 발생할 수 있음.


<br />

### 보정 코드

보정 코드는 발생한 오류를 수정하고 기능을 변경하는데, 만드는 방법은 매우 다양함.

보정 동작이 여러 곳에 분포되어 있으면 많은 영역의 코드가 수정돼야 한다. 소스에서 보정된 코드가 많으면 가독성이 떨어진다. 

**어댑터 패턴**은 이처럼 보정만을 위해 설계된 객체. 수정 불가능한 문제를 분리된 객체로 쉽게 해결할 수 있도록 도와줌. 문제의 코드를 원하는 요구 사항에 맞춰 변경하도록 한다. 

연관성이 없는 2개의 객체를 묶어 인터페이스를 통일화. 통일화된 변경 인터페이스로 기존의 코드를 재사용함.

<br />


## 7.3 어댑터

코드를 재사용하기 위한 인터페이스를 처리하고 인터페이스를 활용해 보정 코드를 작성

<br />

### wrapper

어댑터 패턴은 다른 말로 **래퍼 패턴wrapper pattern** 이라고 하는데, 기존의 클래스를 새로운 클래스로 감싸는 기법

기존의 기능은 유지하면서 변경된 추가 코드를 삽입 래퍼 처리된 객체를 어댑터라고 함

- **Adapter** : 변환을 처리하는 객체

- **Adaptee** : 변환을 받아 사용하는 객체

<br />

### 7.3.2 호환성

문제점을 가진 객체를 해퍼하면 새로운 객체가 된다. 기존 객체를 감싼 또 다른 객체인 것. 새로 생성되는 객체는 클라이언트-어댑티 간 호환을 위해 인터페이스를 갖고 있음.

하지만 어갭티가 기존 객체client의 인터페이스와 호환되지 않을 수도 있는데, 이때는 새로운 환경에 맞게 인터페이스(어댑터)를 재설계해야 함.

어댑터는 어댑티가 클라이언트와 통신할 수 있도록 인터페이스의 구조를 변경함.

<br />

### 7.3.3 중개 행동 패턴

래퍼 처리된 새로운 객체(어댑티)는 기존의 코드와 새로운 환경(클라이언트)간의 역할을 중개

어댑티가 원활한 중개를 하기 위해 인터페이스를 개설계함

어갭터 패턴은 2개의 클래스를 중개한다고 해서 중개 패턴으로 불리기도 하고 중개적인 특징을 이영해 코드의 재사용을 높임

새로운 기능을 제공하는 것이 아니라, 산순한 변환과 전달 역할만을 목적으로 함.

<br />

### 7.3.4 어댑터의 종류.

다른 객체의 구조를 내가 원하는 인터페이스 방식으로 개선

- 클래스 어댑터: 상속

- 객체 어댑터 : 구성

<br />

### 7.3.5 클라이언트

어댑터 패턴을 적용하면 클라이언트 입장에서는 변화된 것이 없는 것처럼 사용할 수 있음. 중간역한의 어댑터가 내부적으로 처리 로직을 변경하여 동작을 수행하기 때문에 클라이언트는 기존 방긱과 동일하게 코드를 작성해서 사용하면 됨.

<br />

## 7.4 클래스 어댑터

클래스 어댑터는 클래스의 상속 특성을 이용하며, 클래스 어댑터를 사용하기 위해서는 다중 상속이 필요

<br />

### 7.4.1 다중 상속

다중 상속은 하나의 클래스가 2개 이상의 클래스에서 상속되는 것을 말하지만, 최신 프로그래밍 언어는 다중 상속을 지원하지 않음. 다중 상속은 메서드 충돌이 발생하며 2개 이상의 클래스에서 동일한 메서드 명을 사용할 경우 어느 것을 기준으로 해야하는지 판단할 수 없음. 

<br />

### 7.4.2 장점

클래스 어댑터는 별도의 어댑티를 만들지 않으며, 하나의 클래스로 어댑터 객체를 처리할 수 있음. 클래스 어댑터를 사용할 경우 클라이언트는 코드를 수정하지 않음. 특별한 변화 작업 없이 가존의 코드를 그대로 사용할 수 있다는 장점. 

<br />

### 7.4.3 단점

여러 개의 클래스가 필요한 경우 계층적으로 상속을 받음. 이처럼 계층적으로 클래스를 상속할 때는 클래스 사이에 강한 결합이 형성됨.

클래스 어댑터를 사용하면 1개의 클래스 만으로도 기능을 보정할 수 있는데, 계층적으로 상속 받은 클래스가 상위 클래스의 메서드를 포함하기 때문. 

별도로 다시 메서드를 구현하지 않아도 하위 클래스에서 사용할 수도 있고, 하위 클래스에서 상위 메서드를 다시 재정의 하는 오버라이딩을 활용 할 수 있음.

<br />

## 7.5 객체 어댑터

객체 어댑터는 객체의 의존성을 이용해 문제를 해결. 객체 어댑터는 기존 타깃인 객체의 인터페이스에 영향을 받으며 타깃의 인터페이스가 복잡할수록 많은 작업이 필요함.

<br />

### 7.5.1 구성

객체 어댑터는 내부적으로 객체를 재구성함. 구성을 위해 기존 객체는 복합 객체로 변환됨.

객체 어댑터의 구성은 변환될 객체를 의존성 관계로 연결. 의존성 연결은 어댑터 객체에서 직접 생성할 수 있으며 외부에서 인자로 받아 주입할 수도 있음. 구성으로 변경된 객체는 서브 클래스의 동작도 같이 처리

<br />

### 7.5.2 캡슐화

어댑터는 변경된 인터페이스로 캡슐화되어있기 때문에, 클라이언트에서 다른 수정없이 사용할 수 있음. 어갭터 패턴은 객체의 호환성을 개선하기 위한 기능들로 새롭게 합성함. 

기능상으로 문제없이 동작하는 코드가 단지 인터페이스 차이 때문에 사용할 수 없는 경우 많은 응용되며, 기존 코드에 오류가 있거나 보정 작업이 필요한 경우에도 매우 유용함.

<br />

### 7.5.3 장점

객체를 구성으로 결합하면 느슨한 연결 방식으로 보다 많은 유연성을 확보할 수 있음. 이 구성은 프로그램이 실행되는 도중에도 객체를 변경할 수 있음

<br />

### 7.5.3 단점

객체를 구성으로 결합하면 어댑터는 클라이언트에서 사용하는 인터페이스 방식으로 메서드를 새로 생성하기 때문에 추가적인 코드가 필요

<br />

## 7.6.5 결과

어댑터 패턴을 사용하기 전에 어댑터와 어탭티 간의 유사성을 찾아보는 것이 중요. 변경 작업을 많이 할 경우 어댑터 패턴의 의미를 잃어버릴 수도 있음.

프로젝트에서 어댑터 패턴을 적용한다고 해서 코드의 성능이 개선되는 것은 아님 오히려 어댑터를 통해야 하므로 속도가 저하되며 어댑터 패턴은 복잡한 객체 구조를 깔끔하게 정리하는 데 유용

<br />

## 7.7 관련 패턴

인터페이스를 처리한다는 점에서 퍼사드 패턴이나 프록시 패턴과 구조적으로 유사한 점이 많음. 보정 및 버그를 개성하기 위해 추가되는 기능은 장식자 패턴과도 유사함

|  | 퍼사드 패턴 | 브리지 패턴 | 장식자 패턴 |
| --- | --- | --- | --- |
| 비슷한 점 | 여러개의 인터페이스를 사용할 경우 퍼사드 패턴과 유사한 특성을 가짐 | 서로 다른 클래스 연결 문제를 해결하는 것이 유사. 브리지는 기능 계층과 구현 계층을 연결하는 패턴. | 장식자 패턴은 인터페이스를 변경하지 않고 기능을 추가하는 패턴. |
| 다른 점 |  | 브리지 패턴은 추상 개념을 이용하여 코드를 분리하는 반면, 어댑터 패턴은 기존의 인터페이스를 변경하는 것을 목적으로 함. | 기존의 어댑터는 새로운 기능을 추가하기 보다 변경된 이내터페이스로 맞춰 전달하는 역할. 하지만 장식자는 기존의 기능에 새로운 기능이 추가된 객체를 전달함. 장식자 패턴은 객체의 동적 확장 개념을 사용 |

<br />

## 7.8 정리

어댑터 패턴은 간단히 구현할 수 있으며 기존의 코드를 변환하여 재정의

객체를 햅으로 감싸서 만들어 사용하는 것이 마치 래퍼와 유사.

코드를 재정의 할 때는 추가하거나 변경해야하는 부분이 발생. 원본의 코드에서 처리하는 것보다 어댑터 패턴에서 재정의한 코드에 추가하는 것이 좋음 그렇게 하면 원본의 코드를 수정하지 않고 프로젝트에 적용할 수 있음.

레거시 코드나 라이브러리를 재사용할 때 유용한 패턴. 서로 호환되지 않는 인터페이스를 가진 코드를 결합하여 응용 프로그램에서 동작할 수 있도록 도와줌
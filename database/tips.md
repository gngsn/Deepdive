# 성능 최적화 팁 정리


### Tip 1.

DB성능의 대부분은 I/O 엑세스에서 발생.

I/O 튜닝의 핵심 원리는 아래 2가지 항목이 됨

  1. Sequential 액세스의 선택도를 높인다(레코드간 논리적 또는 물리적인 순서를 따라 차례대로 읽음)
  2. Random 액세스 발생량을 줄임(레코드간 논리적, 물리적인 순서를 따르지 않고 한건을 읽기 위해 한 블록씩접근)


### Tip 2. tuning tip

#### 1. 인덱스 스캔

거의 모든 DBMS는 B-Tree 계열 인덱스를 사용한다. 인덱스 종류에 대한 특별한 언급이 없다면 아마도 B-Tree 계열 인덱스를 의미할 것이다. CUBRID는 B+-Tree를 이용하고 있다. B+-Tree는 B-Tree의 한 종류로서, 일반적인 B-Tree와 달리 데이터 포인터를 리프(Leaf) 노드에만 저장한다. 리프 노드의 상위 레벨인 비리프(Non-Leaf) 노드는 전형적인 B-Tree 로 구성되며 리프 노드를 빠르게 찾는 인덱스 역할을 한다. 리프 노드에는 키와 키에 대응하는 데이터의 포인터가 저장되어 있다. 다음 그림은 전형적인 B+-Tree 모습이다.

<img src="./img/b-tree.png" alt="b-tree" width="40%">

B+-Tree의 리프 노드는 링크드 리스트(linked list)로 서로 연결되어 있고, 저장된 키는 정렬되어 있어서 순차 처리가 용이하다. 그렇기 때문에 범위를 검색하는 데 유리하다. 테이블에서는 처음부터 끝까지 모든 레코드를 읽어야 완전한 결과 집합을 얻을 수 있지만, 인덱스는 키-칼럼 순으로 정렬되어 있기 때문에 특정 위치에서 검색을 시작해서 검색 조건이 일치하지 않는 값을 만나는 순간 검색을 멈출 수 있다. 이것을 인덱스 범위 스캔(Index Range Scan)이라고 한다. CUBRID는 범위 스캔을 B+-Tree 검색의 기본 연산으로 제공하고 있다. 범위 스캔에는 두 개의 키가 필요한데, 범위의 양 끝을 표현하는 하위 키(Lower Key)와 상위 키(Upper Key)가 그것이다.

인덱스 범위 스캔은 다음 그림과 같이 두 단계로 진행된다. 첫 번째 단계에서는 루트에서부터 트리를 순회하여 리프 노드에서 하위 키를 찾는다. 두 번째 단계에서는 첫 번째 단계에서 찾은 키에서부터 상위 키까지 순차적으로 레코드를 읽어 처리한다. 상위 키가 현재 노드에서 발견되지 않으면 다음 노드를 읽어 상위 키를 가진 노드까지 검색을 계속해 나간다. 상위 키까지 순차 검색이 끝나면 전체 범위 검색이 완료된다.


참고 [d2:helloword](https://d2.naver.com/helloworld/1155)


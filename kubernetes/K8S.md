# K8S

---

*2022.07.13 | Container Overview*

*keywork     | container, orchestration*

## Container

 **

![스크린샷 2022-07-13 오후 2.14.30.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.14.30.png)

dockerfile을 잘 작성하는 법에 대해 생각할 필요가 있다.

🔗 참고 링크 : [Dockerfile](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)

TL;DR | 최대한 안변하는 것들을 위에 쌓아서 변화를 줄이자.

어떤 process로 building이 되는 구나를 파악하면 되겠다.

### Best Practice

**✔️ 이미지 최적화** : 경량화, 빌드 캐시 최적화

→ 1GB ? 7GB? Boot Straping, Terminated 되는 시간이 오래 걸린다면 기존의 VM과 차별성이 떨어진다.

→ 신속성을 제공하지 못하기 때문에 최대한 가볍게 만들어야 한다.

✔️ **이미지 버전 관리** : Github를 사용하는 것처럼 롤백 등과 같이 이미지 버전 관리가 필요하다.

✔️ **이미지 취약점 스캔**

✔️ **배포 자동화** : 수동으로 하지 않고 애자일하게 처리할 수 있게끔

**✔️ 불변성 유지** 

- 컨테이너가 동작하는 동안 업데이트, 패치, 구성 변경 지양
- 변경 사항이 있을 경우, 새 이미지를 빌드하고 다시 배포

→ Immutable. 한 컨테이너 안에서 수정하면 의미가 없기 때문에 불변한 이미지로 관리

✔️ **로깅 및 모니터링 메카니즘 설계**

- 컨테이너 네이티브한 로깅 및 모니터링 권고(Prometheus, fluentbit 등)

컨테이너 오케스트레이션 툴이 잘 동작하는가? 에 대해 depth를 3단계로 생각해볼 필요가 있다.

사실, 하나의 컨테이너를 사용할 때는 컨테이너 서비스를 사용하지 않아도 된다.

컨테이너 하나가 죽으면 처리해야 하니까 고가용성을 고려한 설치

분산 처리해서 만들자는 관념에서 프로덕션, 테스트 레벨 급을 생각했을 때 하나의 Host OS 위에서 관리는 굉장히 비싸겠죠.

> 방금 만든 컨테이너를 어떤 호스트에 올려야 하지? 
내/외부 통신은 어떻게 해야하지?
시크릿 관리는 어떻게 하지?
다수의 환경 변수 값은 어디서 관리해야 하지?
A Host 는 컨테이너가 20개 있는데, C Host에는 5개 밖에 없는데, 어떻게 효율적으로 관리할까?
Health Check로 Container 상태를 어떻게 체크하지?
> 

![스크린샷 2022-07-13 오후 2.31.44.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.31.44.png)

1. Control plane : EKS versus ECS. 명령을 받고, 어떤 Data plane에 전달할지를 선택
2. Data plane : 실제 올려지는 곳

정상적인 Container인지를 확인하고 관리한다.

AWS ECR, AWS Fargate 중 하나를 선택해서 사용하며, 혹은 Hybrid으로도 사용할 수도 있다.

![스크린샷 2022-07-13 오후 2.34.43.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.34.43.png)

---

| Goal | 쿠버네티스 개념. 키워드에 대한 이해

## K8S ?

왜 필요할까?

![스크린샷 2022-07-13 오후 2.53.31.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.53.31.png)

production level에서는 위의 그림처럼 복잡해진다.

과거에는 Docker swarm, k8s, mesos 등과 같은 Orchestration Tool이 많았다.

cncf 를 확인하면 어떤 트랜드를 따라가고 있나를 생각해봤을 때 도움이 된다.

![스크린샷 2022-07-13 오후 2.55.17.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.55.17.png)

Scheduling

: 내가 방금 배포한 컨테이너가 어떤 host에 넣어야 효율적인지

Self Healing 

: 문제가 생겼을 때 자동으로 대응

Load Balancing

: 하나의 컨테이너에만 End User와 연결된다면 Throwtling, OOM이 걸릴 수도 있기 때문에 밸런싱하는 역할

Auto Scaling

: Flexible하게 pod(최소 실행 단위)안에 하나의 container만 있다면

특정 트리거 point 에 의해 pod의 개수(HPA)나 크기(VPA)를 조절.

Data Plane인 Work Node

Rolling Update

: V1 → V2 서서히 채워 나가는 업데이트 지원

Portability

: 컨테이너 자체의 특징. 이식가능성.

## K8S Architecture

![스크린샷 2022-07-13 오후 3.01.55.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.01.55.png)

쿠버네티스 안에 다양한 컴포넌트가 존재

kubelet - worker node의 소대장

etcd - 모든 logging 저장소

![스크린샷 2022-07-13 오후 3.03.02.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.03.02.png)

Master Node - Control Plane. Data Plane에 명령을 내림

Worker Node - Data Plane

코런? 방식3개를 구축해서 sync가 맞으면 살아났을 때 

### API Server

![스크린샷 2022-07-13 오후 3.05.01.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.05.01.png)

명령을 내릴 때의 관문으로 보시면 된다.

### Conrtoller Manager

![스크린샷 2022-07-13 오후 3.06.00.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.06.00.png)

여러개의 컨트롤러가 존재

컨트롤러가 각각의 Object(Deployment Controller, ReplicaSet Controller, node Controller)를 관리. 이러한 Controller를 관리하는 게 Controller Manager.

특정 Object를 사용하고 싶은데 K8s-native하지 않다면(Ingress-controller, like as ALB-ingress controller), Controller 를 설치를 해서 Ingress 설정하라는 명령을 내려 만들어달라는 요청을 할 수 있다.

### Scheduler

![스크린샷 2022-07-13 오후 3.08.15.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.08.15.png)

placing 되어야 하는데 아직 배치되지 않는 pod를 감시하고 Node 선택

모든 Object 가 decoupling 되어있기 때문에 어떤 흐름으로, 어떻게 연결되어있는지를 주목해서 알아보면 이해하는데 쿠버를 좋다.

배포하려는 pod는 worker node 보다 용량이 크다면 더 큰 용량의 node를 찾아서 배치

어떤 pod는 특정 tag가 정해진 Node에만 배치되라는 설정도 가능하다.

### etcd

![스크린샷 2022-07-13 오후 3.10.48.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.10.48.png)

---

*Data Plane 영역*

### kubelet

명령을 받기도 하지만 자신의 상태가 어떤지도 전달하는 명령도 있음

![스크린샷 2022-07-13 오후 3.11.23.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.11.23.png)

### kube-proxy

![스크린샷 2022-07-13 오후 3.11.38.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.11.38.png)

DaemonSet의 의미? 마치 하나의 worker node에 하나씩 붙어있다는 의미 (fyi. Sidecar)

### Pod

![스크린샷 2022-07-13 오후 3.13.29.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.13.29.png)

가장 작은 Object

결국 worker node에 있기 때문에 localhost로 서로의 pod와 통신할 수 있다.

하나의 고유한 IP를 받음.

---

### Kubernetes Configuration

![스크린샷 2022-07-13 오후 3.15.04.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.15.04.png)

**명령형** : 

**선언형** : 특정 yaml 에 정의해두고 관리

여러명이 관리하기 때문에 명령형은 일시적인 명령을 개인적으로 사용한다면 공유가 어렵고 관리가 어렵다.

또, 히스토리 측면에서도 선언형이 좋다.

![스크린샷 2022-07-13 오후 3.17.21.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.17.21.png)

위 둘의 간극이 있다면 그 둘을 맞추는 게 쿠버의 역할

![스크린샷 2022-07-13 오후 3.17.36.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.17.36.png)

번개 모양이 필수요소.

**apiVersion**

kind는 api 버전 값이 다름.

api 버전은 k8s cluster에 따라서 다를 수도 있다.

즉, k8s cluster가 버전업이 되었을 때 확인해볼 필요가 있다.

**annotation**

k8s에서 filtering 하거나 참고할 때의 관점에서 사용된다.

JSON 형식의 복잡하게 구성되곤 한다.

![스크린샷 2022-07-13 오후 3.20.23.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.20.23.png)

spec: 어떤 contianer를 사용할지에 대한 정보. pod 관련된 정보. deploy 할 때 match labels가 있다 ~

![스크린샷 2022-07-13 오후 3.21.43.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.21.43.png)

---

기본적으로 알아야할 Object

![스크린샷 2022-07-13 오후 3.22.11.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.22.11.png)

workload 생성을 위한 기본 컨셉

![스크린샷 2022-07-13 오후 3.22.56.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.22.56.png)

deployment로 pod를 관리하면 되는구나 ~

![스크린샷 2022-07-13 오후 3.23.31.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.23.31.png)

Addon: k8s의 악세서리. 필수적인 것은 아니지만 돋보일 수 있는 것. default로 되어있지 않기 때문에 설치해야한다.

### Declarative Deployment

![스크린샷 2022-07-13 오후 3.24.50.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.24.50.png)

1. pod 생성 명령
2. deployment 생성
3. deployment controller가 보고 있다가 겹겹히 있던 ReplicaSet 생성

kubelet을 통해 특정 node에 배포가 되고 있다.

![스크린샷 2022-07-13 오후 3.26.44.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.26.44.png)

백업 / 통신 (두 개의 컴포넌트가 중요하구나) /

api server에 통신하는 call이 많구나 

## K8S 인증

1. 인증
2. 인가 → default namespace.. 등 다양한 namespace가 존재하며, namespace 마다 접근 권한을 따로 설정할 수 있다.

개발자

service account : pod가 가질 수 있는 권한

Role : Cluster 전체? namespace 만? 그 범위를 생각해볼 수 있다.

“Authentication을 위한 구성요소는 포함하고 있지 않으면”의 의미

→ 표준을 정해놓지 않기 때문에 입맛에 맞게 구성할 수 있다.

## K8S Storage

### Volumn

![스크린샷 2022-07-13 오후 3.33.39.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.33.39.png)

Pod와 Volumn을 연결

![스크린샷 2022-07-13 오후 3.33.58.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.33.58.png)

HostPath: Worker Node도 결국 EC2이기 때문에 EBS에 mounting해서 사용한다.

EBS 특정 subnet에 위치하는데 여러 worker node가 접근하고 싶을 수 있기 때문에 EFS를 사용할 수 있다.

Persistent Volumn

### Persistent Column 생명주기

![스크린샷 2022-07-13 오후 3.36.09.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.36.09.png)

죽거나 terminated되었을 때 복구할 수 있는 설정이 있다.

실행이 다 되면 (비정상적인 종료) 끝나서 수명주기가 굉장히 짧기 때문에 storage가 따로 있다.

## K8S Qua..

### Container Resource Allocation

![스크린샷 2022-07-13 오후 3.39.28.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.39.28.png)

limit 을 지정해서 장애 전파를 얻을 수 있다.

처음에는 물론 값을 정할 수 없겠지만, 운영하다 보면 누적되는 데이터를 기준으로 잘 설절해서 공유 컴퓨팅 공간을 효과적으로 관리할 수 잇다.

pod 안에 container가 두 개 있는데, 각각 Request, limit을 지정할 수 있다.

### CPU/Memory Allocation

![스크린샷 2022-07-13 오후 3.40.22.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.40.22.png)

요청한 사이즈를 보고 요청한 사이즈를 감당할 수 있다면 할당한다.

### QoS Class

### Pod/Node 자동 확장

![스크린샷 2022-07-13 오후 3.42.06.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.42.06.png)

HPA: Pod

VPA: Spec 늘리는 것

![스크린샷 2022-07-13 오후 3.42.44.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.42.44.png)

추후의 실습을 통해 메트릭 설치를 해서 수집을 할 수 있게끔 만든다.

Auto scaling과 hpa가 비슷하게 동작한다고 생각하면 될 것 같다.

![스크린샷 2022-07-13 오후 3.44.41.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.44.41.png)

HPA도 특정 Object → Controller가 있음 

![스크린샷 2022-07-13 오후 3.45.08.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.45.08.png)

## Kubernetes Network

![스크린샷 2022-07-13 오후 3.45.56.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.45.56.png)

Bridge, Host, Container, None (e.g. batch job같은 경우)

### Pod Networking

![스크린샷 2022-07-13 오후 3.46.20.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.46.20.png)

### CNI, Container Network Interface

AWS - VPC CNI 지원

### Kubernetes Networking

container-1, 2는 통신이 어렵지 않음

하지만 container-4로 갈때에는? → overlay network

VXLAN  조금 더 무겁다 ~

### K8S Service Type

![스크린샷 2022-07-13 오후 3.50.00.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.50.00.png)

deployment yaml → pod 3개 올렸었죠.

서비스가 왜 필요할까? pod와 lifecycle이 동일하기 때문에 죽으면 같이 죽음

pod는 계속 IP가 변경 → IP로 매칭할 수 없고, End User에서 Service로 pod를 매칭받는다.

### K8S 서비스 타입별 트래픽 흐름 (Cluster IP)

![스크린샷 2022-07-13 오후 3.51.50.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.51.50.png)

![스크린샷 2022-07-13 오후 3.52.02.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.52.02.png)

IPVS → 대규모 worker node에서 조금 더 좋은 성능을 볼 수 있다.

중요한 건, Service Object Type이 3개가 있는데 하나는 웹과 통신이 불가능하고 그게 바로 Cluster IP이다.

![스크린샷 2022-07-13 오후 3.53.25.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.53.25.png)

Service Type - Load Balance

NLB가 배포되고, NLB를 타고 통신이 된다. 

![스크린샷 2022-07-13 오후 3.54.30.png](./K8S/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-07-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.54.30.png)

Ingress: 서비스 앞 단에 위치. service를 하나로 묶은 것

(pod을 묶은게 Service..)

SSL 설정할 때도 Ingress Service를 사용할 수 있다.